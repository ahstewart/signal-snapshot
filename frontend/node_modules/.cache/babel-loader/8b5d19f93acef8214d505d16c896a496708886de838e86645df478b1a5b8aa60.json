{"ast":null,"code":"/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance = null;\nlet sqlJsInitPromise = null;\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([import('sql.js'), fetch('/sql-wasm.wasm').then(res => {\n          if (!res.ok) {\n            throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n          }\n          return res.arrayBuffer();\n        })]);\n        const initSqlJs = SQLModule.default;\n        const SQL = await initSqlJs({\n          wasmBinary\n        });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\nexport async function decryptDatabase(encrypted, password) {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt({\n      ciphertext: ciphertext\n    }, key, {\n      iv: iv,\n      mode: CryptoJS.mode.CBC,\n      padding: CryptoJS.pad.Pkcs7\n    });\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(dbBuffer, key, conversationIds) {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00 // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function processDatabase(dbBuffer, conversationIds) {\n  try {\n    var _mostMessagesSent$, _mostReactionsGiven$, _mostReactionsReceive, _mostMentioned$, _mostEggplantsSent$, _mostMediaSent$;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias, idColumn = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n    const analytics = {\n      all_conversations: [],\n      message_counts: {\n        by_day: {},\n        by_hour: {}\n      },\n      top_conversations: [],\n      kpis: {\n        total_messages: 0,\n        total_conversations: 0,\n        avg_messages_per_day: 0\n      },\n      reactions: {\n        total_reactions: 0,\n        top_emojis: [],\n        top_emojis_by_author: {}\n      },\n      awards: {\n        most_messages_sent: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_given: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_received: {\n          winner: null,\n          count: 0\n        },\n        most_mentioned: {\n          winner: null,\n          count: 0\n        },\n        most_eggplants_sent: {\n          winner: null,\n          count: 0\n        },\n        most_media_sent: {\n          winner: null,\n          count: 0\n        }\n      }\n    };\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]) => ({\n          id,\n          name\n        }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostEggplantsSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} body LIKE '%ðŸ†%' AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostEggplantsSent, mostMediaSent] = [db.exec(mostMessagesSentQuery), db.exec(mostReactionsGivenQuery), db.exec(mostReactionsReceivedQuery), db.exec(mostMentionedQuery), db.exec(mostEggplantsSentQuery), db.exec(mostMediaSentQuery)];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]) => ({\n      name,\n      count\n    }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts = {};\n      const authorEmojiCounts = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({\n        emoji,\n        count\n      }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({\n          emoji,\n          count\n        }));\n      }\n    }\n\n    // Process Award Results\n    if ((_mostMessagesSent$ = mostMessagesSent[0]) !== null && _mostMessagesSent$ !== void 0 && _mostMessagesSent$.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0];\n      analytics.awards.most_messages_sent = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsGiven$ = mostReactionsGiven[0]) !== null && _mostReactionsGiven$ !== void 0 && _mostReactionsGiven$.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0];\n      analytics.awards.most_reactions_given = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsReceive = mostReactionsReceived[0]) !== null && _mostReactionsReceive !== void 0 && _mostReactionsReceive.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0];\n      analytics.awards.most_reactions_received = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMentioned$ = mostMentioned[0]) !== null && _mostMentioned$ !== void 0 && _mostMentioned$.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0];\n      analytics.awards.most_mentioned = {\n        winner,\n        count\n      };\n    }\n    if ((_mostEggplantsSent$ = mostEggplantsSent[0]) !== null && _mostEggplantsSent$ !== void 0 && _mostEggplantsSent$.values[0]) {\n      const [winner, count] = mostEggplantsSent[0].values[0];\n      analytics.awards.most_eggplants_sent = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMediaSent$ = mostMediaSent[0]) !== null && _mostMediaSent$ !== void 0 && _mostMediaSent$.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0];\n      analytics.awards.most_media_sent = {\n        winner,\n        count\n      };\n    }\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\nexport async function getUsers(dbBuffer) {\n  try {\n    var _messageSendersResult, _reactionGiversResult, _reactionReceiversRes;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const messageSendersQuery = `SELECT DISTINCT source FROM messages WHERE source IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = ((_messageSendersResult = messageSendersResult[0]) === null || _messageSendersResult === void 0 ? void 0 : _messageSendersResult.values.map(([id]) => id)) || [];\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = ((_reactionGiversResult = reactionGiversResult[0]) === null || _reactionGiversResult === void 0 ? void 0 : _reactionGiversResult.values.map(([id]) => id)) || [];\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = ((_reactionReceiversRes = reactionReceiversResult[0]) === null || _reactionReceiversRes === void 0 ? void 0 : _reactionReceiversRes.values.map(([id]) => id)) || [];\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n    const users = allUserIds.map(id => ({\n      id: id,\n      name: id\n    })).sort((a, b) => a.name.localeCompare(b.name));\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\nexport async function getIndividualStats(dbBuffer, userId) {\n  try {\n    var _totalMessagesResult$, _totalMessagesResult$2, _popularDayResult$, _popularDayResult$$va, _totalReactionsResult, _totalReactionsResult2;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE source = '${userId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = ((_totalMessagesResult$ = totalMessagesResult[0]) === null || _totalMessagesResult$ === void 0 ? void 0 : (_totalMessagesResult$2 = _totalMessagesResult$.values[0]) === null || _totalMessagesResult$2 === void 0 ? void 0 : _totalMessagesResult$2[0]) || 0;\n    const popularDayQuery = `\n      SELECT\n        CASE CAST(strftime('%w', sent_at/1000, 'unixepoch') AS INTEGER)\n          WHEN 0 THEN 'Sunday'\n          WHEN 1 THEN 'Monday'\n          WHEN 2 THEN 'Tuesday'\n          WHEN 3 THEN 'Wednesday'\n          WHEN 4 THEN 'Thursday'\n          WHEN 5 THEN 'Friday'\n          ELSE 'Saturday'\n        END as day,\n        COUNT(*) as count\n      FROM messages\n      WHERE source = '${userId}'\n      GROUP BY day\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const popularDayResult = db.exec(popularDayQuery);\n    const mostPopularDay = ((_popularDayResult$ = popularDayResult[0]) === null || _popularDayResult$ === void 0 ? void 0 : (_popularDayResult$$va = _popularDayResult$.values[0]) === null || _popularDayResult$$va === void 0 ? void 0 : _popularDayResult$$va[0]) || 'N/A';\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userId}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = ((_totalReactionsResult = totalReactionsResult[0]) === null || _totalReactionsResult === void 0 ? void 0 : (_totalReactionsResult2 = _totalReactionsResult.values[0]) === null || _totalReactionsResult2 === void 0 ? void 0 : _totalReactionsResult2[0]) || 0;\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\nexport async function loadUsers(dbBuffer, key) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function loadIndividualStats(dbBuffer, key, userId) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}","map":{"version":3,"names":["CryptoJS","sqlJsInstance","sqlJsInitPromise","getSqlJs","SQLModule","wasmBinary","Promise","all","fetch","then","res","ok","Error","statusText","arrayBuffer","initSqlJs","default","SQL","err","console","error","initializeSQL","createDatabaseFromBuffer","dbBuffer","Database","Uint8Array","decryptDatabase","encrypted","password","keyHex","substring","key","enc","Hex","parse","iv","lib","WordArray","create","slice","ciphertext","decrypted","AES","decrypt","mode","CBC","padding","pad","Pkcs7","decryptedBytes","toString","Latin1","decryptedArray","length","i","charCodeAt","buffer","loadDatabase","conversationIds","sqliteHeader","fileHeader","isDecrypted","every","byte","processDatabase","decryptedBuffer","_mostMessagesSent$","_mostReactionsGiven$","_mostReactionsReceive","_mostMentioned$","_mostEggplantsSent$","_mostMediaSent$","db","buildWhereClause","tableAlias","idColumn","prefix","ids","map","id","join","messagesWhereClause","reactionsWhereClause","conversationsWhereClause","undefined","messagesJoinWhereClause","analytics","all_conversations","message_counts","by_day","by_hour","top_conversations","kpis","total_messages","total_conversations","avg_messages_per_day","reactions","total_reactions","top_emojis","top_emojis_by_author","awards","most_messages_sent","winner","count","most_reactions_given","most_reactions_received","most_mentioned","most_eggplants_sent","most_media_sent","allConvosResults","exec","values","name","byDayResults","byHourResults","topConvoResults","kpiResults","reactionResults","mostMessagesSentQuery","mostReactionsGivenQuery","mostReactionsReceivedQuery","mostMentionedQuery","mostEggplantsSentQuery","mostMediaSentQuery","mostMessagesSent","mostReactionsGiven","mostReactionsReceived","mostMentioned","mostEggplantsSent","mostMediaSent","Object","fromEntries","keys","Math","round","emojiCounts","authorEmojiCounts","forEach","emoji","fromId","entries","sort","a","b","authorId","getUsers","_messageSendersResult","_reactionGiversResult","_reactionReceiversRes","messageSendersQuery","messageSendersResult","messageSenders","reactionGiversQuery","reactionGiversResult","reactionGivers","reactionReceiversQuery","reactionReceiversResult","reactionReceivers","allUserIds","Set","users","localeCompare","getIndividualStats","userId","_totalMessagesResult$","_totalMessagesResult$2","_popularDayResult$","_popularDayResult$$va","_totalReactionsResult","_totalReactionsResult2","totalMessagesQuery","totalMessagesResult","totalMessagesSent","popularDayQuery","popularDayResult","mostPopularDay","totalReactionsQuery","totalReactionsResult","totalReactionsSent","loadUsers","loadIndividualStats"],"sources":["E:/ahste/Projects/signal-analytics/frontend/src/utils/database.ts"],"sourcesContent":["/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance: any = null;\nlet sqlJsInitPromise: Promise<any> | null = null;\n\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([\n          import('sql.js'),\n          fetch('/sql-wasm.wasm').then(res => {\n            if (!res.ok) {\n              throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n            }\n            return res.arrayBuffer();\n          })\n        ]);\n\n        const initSqlJs = SQLModule.default as unknown as (config: any) => Promise<any>;\n        const SQL = await initSqlJs({ wasmBinary });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\n\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer: ArrayBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\n\nexport interface Conversation {\n  id: string;\n  name: string;\n}\n\nexport interface Award {\n  winner: string | null;\n  count: number;\n}\n\nexport interface AnalyticsData {\n  all_conversations: Conversation[];\n  message_counts: {\n    by_day: Record<string, number>;\n    by_hour: Record<string, number>;\n  };\n  top_conversations: {\n    name: string;\n    count: number;\n  }[];\n  kpis: {\n    total_messages: number;\n    total_conversations: number;\n    avg_messages_per_day: number;\n  };\n  reactions: {\n    total_reactions: number;\n    top_emojis: { emoji: string; count: number }[];\n    top_emojis_by_author: Record<string, { emoji: string; count: number }[]>;\n  };\n  awards: {\n    most_messages_sent: Award;\n    most_reactions_given: Award;\n    most_reactions_received: Award;\n    most_mentioned: Award;\n    most_eggplants_sent: Award;\n    most_media_sent: Award;\n  };\n}\n\nexport async function decryptDatabase(\n  encrypted: ArrayBuffer,\n  password: string\n): Promise<ArrayBuffer> {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt(\n      { ciphertext: ciphertext } as any,\n      key,\n      {\n        iv: iv,\n        mode: CryptoJS.mode.CBC,\n        padding: CryptoJS.pad.Pkcs7,\n      }\n    );\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(\n  dbBuffer: ArrayBuffer,\n  key?: string,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00, // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n\n  const isDecrypted =\n    fileHeader.length === sqliteHeader.length &&\n    fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function processDatabase(\n  dbBuffer: ArrayBuffer,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias?: string, idColumn: string = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n\n    const analytics: AnalyticsData = {\n      all_conversations: [],\n      message_counts: { by_day: {}, by_hour: {} },\n      top_conversations: [],\n      kpis: { total_messages: 0, total_conversations: 0, avg_messages_per_day: 0 },\n      reactions: { total_reactions: 0, top_emojis: [], top_emojis_by_author: {} },\n      awards: {\n        most_messages_sent: { winner: null, count: 0 },\n        most_reactions_given: { winner: null, count: 0 },\n        most_reactions_received: { winner: null, count: 0 },\n        most_mentioned: { winner: null, count: 0 },\n        most_eggplants_sent: { winner: null, count: 0 },\n        most_media_sent: { winner: null, count: 0 },\n      },\n    };\n\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]: [string, string]) => ({ id, name }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostEggplantsSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} body LIKE '%ðŸ†%' AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostEggplantsSent, mostMediaSent] = [\n      db.exec(mostMessagesSentQuery),\n      db.exec(mostReactionsGivenQuery),\n      db.exec(mostReactionsReceivedQuery),\n      db.exec(mostMentionedQuery),\n      db.exec(mostEggplantsSentQuery),\n      db.exec(mostMediaSentQuery),\n    ];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]: [string, number]) => ({ name, count }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0] as [number, number];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0,\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts: Record<string, number> = {};\n      const authorEmojiCounts: Record<string, Record<string, number>> = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]: [string, string, number]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({ emoji, count }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({ emoji, count }));\n      }\n    }\n\n    // Process Award Results\n    if (mostMessagesSent[0]?.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0] as [string, number];\n      analytics.awards.most_messages_sent = { winner, count };\n    }\n    if (mostReactionsGiven[0]?.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0] as [string, number];\n      analytics.awards.most_reactions_given = { winner, count };\n    }\n    if (mostReactionsReceived[0]?.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0] as [string, number];\n      analytics.awards.most_reactions_received = { winner, count };\n    }\n    if (mostMentioned[0]?.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0] as [string, number];\n      analytics.awards.most_mentioned = { winner, count };\n    }\n    if (mostEggplantsSent[0]?.values[0]) {\n      const [winner, count] = mostEggplantsSent[0].values[0] as [string, number];\n      analytics.awards.most_eggplants_sent = { winner, count };\n    }\n    if (mostMediaSent[0]?.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0] as [string, number];\n      analytics.awards.most_media_sent = { winner, count };\n    }\n\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface IndividualStatsData {\n  totalMessagesSent: number;\n  mostPopularDay: string;\n  totalReactionsSent: number;\n}\n\nexport async function getUsers(dbBuffer: ArrayBuffer): Promise<User[]> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const messageSendersQuery = `SELECT DISTINCT source FROM messages WHERE source IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = messageSendersResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = reactionGiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = reactionReceiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n\n    const users: User[] = allUserIds.map(id => ({\n      id: id,\n      name: id,\n    })).sort((a, b) => a.name.localeCompare(b.name));\n\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\n\nexport async function getIndividualStats(\n  dbBuffer: ArrayBuffer,\n  userId: string\n): Promise<IndividualStatsData> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE source = '${userId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = totalMessagesResult[0]?.values[0]?.[0] as number || 0;\n\n    const popularDayQuery = `\n      SELECT\n        CASE CAST(strftime('%w', sent_at/1000, 'unixepoch') AS INTEGER)\n          WHEN 0 THEN 'Sunday'\n          WHEN 1 THEN 'Monday'\n          WHEN 2 THEN 'Tuesday'\n          WHEN 3 THEN 'Wednesday'\n          WHEN 4 THEN 'Thursday'\n          WHEN 5 THEN 'Friday'\n          ELSE 'Saturday'\n        END as day,\n        COUNT(*) as count\n      FROM messages\n      WHERE source = '${userId}'\n      GROUP BY day\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const popularDayResult = db.exec(popularDayQuery);\n    const mostPopularDay = popularDayResult[0]?.values[0]?.[0] as string || 'N/A';\n\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userId}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = totalReactionsResult[0]?.values[0]?.[0] as number || 0;\n\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent,\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\n\nexport async function loadUsers(\n  dbBuffer: ArrayBuffer,\n  key?: string\n): Promise<User[]> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function loadIndividualStats(\n  dbBuffer: ArrayBuffer,\n  key: string | undefined,\n  userId: string\n): Promise<IndividualStatsData> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}