{"ast":null,"code":"/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance = null;\nlet sqlJsInitPromise = null;\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([import('sql.js'), fetch('/sql-wasm.wasm').then(res => {\n          if (!res.ok) {\n            throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n          }\n          return res.arrayBuffer();\n        })]);\n        const initSqlJs = SQLModule.default;\n        const SQL = await initSqlJs({\n          wasmBinary\n        });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\nexport async function decryptDatabase(encrypted, password) {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt({\n      ciphertext: ciphertext\n    }, key, {\n      iv: iv,\n      mode: CryptoJS.mode.CBC,\n      padding: CryptoJS.pad.Pkcs7\n    });\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(dbBuffer, key, conversationIds) {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00 // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function processDatabase(dbBuffer, conversationIds) {\n  try {\n    var _mostMessagesSent$, _mostReactionsGiven$, _mostReactionsReceive, _mostMentioned$, _mostRepliedTo$, _mostMediaSent$;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias, idColumn = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n    const analytics = {\n      all_conversations: [],\n      message_counts: {\n        by_day: {},\n        by_hour: {}\n      },\n      top_conversations: [],\n      kpis: {\n        total_messages: 0,\n        total_conversations: 0,\n        avg_messages_per_day: 0\n      },\n      reactions: {\n        total_reactions: 0,\n        top_emojis: [],\n        top_emojis_by_author: {}\n      },\n      awards: {\n        most_messages_sent: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_given: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_received: {\n          winner: null,\n          count: 0\n        },\n        most_mentioned: {\n          winner: null,\n          count: 0\n        },\n        most_replied_to: {\n          winner: null,\n          count: 0\n        },\n        most_media_sent: {\n          winner: null,\n          count: 0\n        }\n      },\n      funniestUsers: [],\n      userNamesById: {}\n    };\n\n    // Build user ID to name mapping from conversations\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) analytics.userNamesById[id] = name;\n          if (serviceId) analytics.userNamesById[serviceId] = name;\n        }\n      });\n    }\n    console.log('Constructed userNamesById mapping:', analytics.userNamesById);\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]) => ({\n          id,\n          name\n        }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id JOIN conversations c ON mn.mentionAci = c.serviceId ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostRepliedToQuery = `SELECT json_extract(m.json, '$.quote.author') as repliedToAuthor, COUNT(*) as count FROM messages m ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} json_extract(m.json, '$.quote.author') IS NOT NULL GROUP BY repliedToAuthor ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostRepliedTo, mostMediaSent] = [db.exec(mostMessagesSentQuery), db.exec(mostReactionsGivenQuery), db.exec(mostReactionsReceivedQuery), db.exec(mostMentionedQuery), db.exec(mostRepliedToQuery), db.exec(mostMediaSentQuery)];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]) => ({\n      name,\n      count\n    }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts = {};\n      const authorEmojiCounts = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({\n        emoji,\n        count\n      }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({\n          emoji,\n          count\n        }));\n      }\n    }\n\n    // Process Award Results\n    if ((_mostMessagesSent$ = mostMessagesSent[0]) !== null && _mostMessagesSent$ !== void 0 && _mostMessagesSent$.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0];\n      analytics.awards.most_messages_sent = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsGiven$ = mostReactionsGiven[0]) !== null && _mostReactionsGiven$ !== void 0 && _mostReactionsGiven$.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0];\n      analytics.awards.most_reactions_given = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsReceive = mostReactionsReceived[0]) !== null && _mostReactionsReceive !== void 0 && _mostReactionsReceive.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0];\n      analytics.awards.most_reactions_received = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMentioned$ = mostMentioned[0]) !== null && _mostMentioned$ !== void 0 && _mostMentioned$.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0];\n      analytics.awards.most_mentioned = {\n        winner,\n        count\n      };\n    }\n    if ((_mostRepliedTo$ = mostRepliedTo[0]) !== null && _mostRepliedTo$ !== void 0 && _mostRepliedTo$.values[0]) {\n      const [winner, count] = mostRepliedTo[0].values[0];\n      analytics.awards.most_replied_to = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMediaSent$ = mostMediaSent[0]) !== null && _mostMediaSent$ !== void 0 && _mostMediaSent$.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0];\n      analytics.awards.most_media_sent = {\n        winner,\n        count\n      };\n    }\n\n    // KPI: Funniest Users\n    const laughEmojis = ['😂', '🤣', '😆', '😄'];\n    const funniestUsersQuery = `\n      WITH user_message_counts AS (\n        SELECT sourceServiceId, COUNT(*) as total_messages_sent\n        FROM messages\n        GROUP BY sourceServiceId\n      ),\n      latest_laugh_reactions AS (\n        SELECT\n          messageId, targetAuthorAci, emoji,\n          ROW_NUMBER() OVER(PARTITION BY fromId, messageId ORDER BY messageReceivedAt DESC) as rn\n        FROM reactions\n        WHERE emoji IN (${laughEmojis.map(e => `'${e}'`).join(',')})\n      ),\n      user_laugh_reacts_received AS (\n        SELECT targetAuthorAci, COUNT(*) as total_laugh_reacts\n        FROM latest_laugh_reactions\n        WHERE rn = 1\n        GROUP BY targetAuthorAci\n      ),\n      messages_with_laugh_reacts AS (\n        SELECT targetAuthorAci, COUNT(DISTINCT messageId) as num_messages_with_laughs\n        FROM latest_laugh_reactions\n        WHERE rn = 1\n        GROUP BY targetAuthorAci\n      )\n      SELECT\n        c.profileFullName as name,\n        COALESCE(ulrr.total_laugh_reacts, 0) as total_laugh_reacts,\n        CASE\n          WHEN umc.total_messages_sent > 0 THEN CAST(COALESCE(ulrr.total_laugh_reacts, 0) AS REAL) / umc.total_messages_sent\n          ELSE 0\n        END as total_laugh_rate,\n        CASE\n          WHEN mwlr.num_messages_with_laughs > 0 THEN CAST(COALESCE(ulrr.total_laugh_reacts, 0) AS REAL) / mwlr.num_messages_with_laughs\n          ELSE 0\n        END as humor_score\n      FROM conversations c\n      LEFT JOIN user_message_counts umc ON c.serviceId = umc.sourceServiceId\n      LEFT JOIN user_laugh_reacts_received ulrr ON c.serviceId = ulrr.targetAuthorAci\n      LEFT JOIN messages_with_laugh_reacts mwlr ON c.serviceId = mwlr.targetAuthorAci\n      WHERE c.type = 'private' AND c.serviceId IS NOT NULL AND umc.total_messages_sent > 0\n      ORDER BY humor_score DESC;\n    `;\n    const funniestUsersResults = db.exec(funniestUsersQuery);\n    const funniestUsers = funniestUsersResults[0] ? funniestUsersResults[0].values.map(row => ({\n      name: row[0],\n      totalLaughReacts: row[1],\n      totalLaughRate: row[2],\n      humorScore: row[3]\n    })) : [];\n    analytics.funniestUsers = funniestUsers;\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\nexport async function getUsers(dbBuffer) {\n  try {\n    var _messageSendersResult, _reactionGiversResult, _reactionReceiversRes;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Build a comprehensive name mapping from the conversations table\n    const nameMap = new Map();\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) nameMap.set(id, name);\n          if (serviceId) nameMap.set(serviceId, name);\n        }\n      });\n    }\n\n    // Collect all unique user IDs from messages and reactions\n    const messageSendersQuery = `SELECT DISTINCT sourceServiceId FROM messages WHERE sourceServiceId IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = ((_messageSendersResult = messageSendersResult[0]) === null || _messageSendersResult === void 0 ? void 0 : _messageSendersResult.values.map(([id]) => id)) || [];\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = ((_reactionGiversResult = reactionGiversResult[0]) === null || _reactionGiversResult === void 0 ? void 0 : _reactionGiversResult.values.map(([id]) => id)) || [];\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = ((_reactionReceiversRes = reactionReceiversResult[0]) === null || _reactionReceiversRes === void 0 ? void 0 : _reactionReceiversRes.values.map(([id]) => id)) || [];\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n    const uniqueUserIds = Array.from(new Set(allUserIds.filter(id => typeof id === 'string' && id)));\n\n    // Create the User[] array, using the name map\n    const usersWithPotentialDuplicates = uniqueUserIds.map(id => ({\n      id,\n      name: nameMap.get(id) || id // Use mapped name, fallback to ID\n    }));\n\n    // Deduplicate users by name, keeping the first occurrence\n    const uniqueUsersByName = new Map();\n    for (const user of usersWithPotentialDuplicates) {\n      if (!uniqueUsersByName.has(user.name)) {\n        uniqueUsersByName.set(user.name, user);\n      }\n    }\n    const users = Array.from(uniqueUsersByName.values()).sort((a, b) => a.name.localeCompare(b.name));\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\nexport async function getIndividualStats(dbBuffer, userId) {\n  if (!userId) {\n    throw new Error('User ID is required to get individual stats.');\n  }\n  try {\n    var _getIdsResult$, _getIdsResult$$values, _getIdsResult$2, _getIdsResult$2$value, _totalMessagesResult$, _totalMessagesResult$2, _timestampsResult$, _totalReactionsResult, _totalReactionsResult2, _reactedToMostResult$, _receivedMostResult$, _popularMessageResult;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Find the canonical serviceId AND id for the given user ID\n    const getIdsQuery = `SELECT id, serviceId FROM conversations WHERE id = '${userId}' OR serviceId = '${userId}' LIMIT 1`;\n    const getIdsResult = db.exec(getIdsQuery);\n    const userUUID = ((_getIdsResult$ = getIdsResult[0]) === null || _getIdsResult$ === void 0 ? void 0 : (_getIdsResult$$values = _getIdsResult$.values[0]) === null || _getIdsResult$$values === void 0 ? void 0 : _getIdsResult$$values[0]) || userId;\n    const userServiceId = ((_getIdsResult$2 = getIdsResult[0]) === null || _getIdsResult$2 === void 0 ? void 0 : (_getIdsResult$2$value = _getIdsResult$2.values[0]) === null || _getIdsResult$2$value === void 0 ? void 0 : _getIdsResult$2$value[1]) || userId;\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = ((_totalMessagesResult$ = totalMessagesResult[0]) === null || _totalMessagesResult$ === void 0 ? void 0 : (_totalMessagesResult$2 = _totalMessagesResult$.values[0]) === null || _totalMessagesResult$2 === void 0 ? void 0 : _totalMessagesResult$2[0]) || 0;\n\n    // Calculate most popular day in JS for robustness\n    const allTimestampsQuery = `SELECT sent_at FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const timestampsResult = db.exec(allTimestampsQuery);\n    let mostPopularDay = 'N/A';\n    if (((_timestampsResult$ = timestampsResult[0]) === null || _timestampsResult$ === void 0 ? void 0 : _timestampsResult$.values.length) > 0) {\n      const dayCounts = Array(7).fill(0); // Sunday - Saturday\n      timestampsResult[0].values.forEach(row => {\n        const ts = row[0];\n        const date = new Date(ts);\n        dayCounts[date.getDay()]++;\n      });\n      const maxCount = Math.max(...dayCounts);\n      const popularDayIndex = dayCounts.indexOf(maxCount);\n      const dayMap = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n      mostPopularDay = dayMap[popularDayIndex];\n    }\n\n    // Use the user's UUID (conversations.id) for reactions, as per the user's view\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userUUID}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = ((_totalReactionsResult = totalReactionsResult[0]) === null || _totalReactionsResult === void 0 ? void 0 : (_totalReactionsResult2 = _totalReactionsResult.values[0]) === null || _totalReactionsResult2 === void 0 ? void 0 : _totalReactionsResult2[0]) || 0;\n\n    // KPI: Reacted To Most\n    const reactedToMostQuery = `\n      SELECT r.targetAuthorAci, c.profileFullName, COUNT(*) as count\n      FROM reactions r\n      JOIN conversations c ON r.targetAuthorAci = c.serviceId\n      WHERE r.fromId = '${userUUID}'\n      GROUP BY r.targetAuthorAci, c.profileFullName\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const reactedToMostResult = db.exec(reactedToMostQuery);\n    let reactedToMost = null;\n    if ((_reactedToMostResult$ = reactedToMostResult[0]) !== null && _reactedToMostResult$ !== void 0 && _reactedToMostResult$.values[0]) {\n      var _topEmojiResult$, _topEmojiResult$$valu;\n      const targetSvcId = reactedToMostResult[0].values[0][0];\n      const name = reactedToMostResult[0].values[0][1];\n      const count = reactedToMostResult[0].values[0][2];\n      const topEmojiQuery = `\n        SELECT emoji, COUNT(*) as count\n        FROM reactions\n        WHERE fromId = '${userUUID}' AND targetAuthorAci = '${targetSvcId}'\n        GROUP BY emoji\n        ORDER BY count DESC\n        LIMIT 1;\n      `;\n      const topEmojiResult = db.exec(topEmojiQuery);\n      const emoji = ((_topEmojiResult$ = topEmojiResult[0]) === null || _topEmojiResult$ === void 0 ? void 0 : (_topEmojiResult$$valu = _topEmojiResult$.values[0]) === null || _topEmojiResult$$valu === void 0 ? void 0 : _topEmojiResult$$valu[0]) || '??';\n      reactedToMost = {\n        name,\n        count,\n        emoji\n      };\n    }\n\n    // KPI: Received Most Reactions From\n    const receivedMostQuery = `\n      SELECT r.fromId, c.profileFullName, COUNT(*) as count\n      FROM reactions r\n      JOIN conversations c ON r.fromId = c.id\n      WHERE r.targetAuthorAci = '${userServiceId}'\n      GROUP BY r.fromId, c.profileFullName\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const receivedMostResult = db.exec(receivedMostQuery);\n    let receivedMostReactionsFrom = null;\n    if ((_receivedMostResult$ = receivedMostResult[0]) !== null && _receivedMostResult$ !== void 0 && _receivedMostResult$.values[0]) {\n      var _topEmojiResult$2, _topEmojiResult$2$val;\n      const fromId = receivedMostResult[0].values[0][0];\n      const name = receivedMostResult[0].values[0][1];\n      const count = receivedMostResult[0].values[0][2];\n      const topEmojiQuery = `\n        SELECT emoji, COUNT(*) as count\n        FROM reactions\n        WHERE fromId = '${fromId}' AND targetAuthorAci = '${userServiceId}'\n        GROUP BY emoji\n        ORDER BY count DESC\n        LIMIT 1;\n      `;\n      const topEmojiResult = db.exec(topEmojiQuery);\n      const emoji = ((_topEmojiResult$2 = topEmojiResult[0]) === null || _topEmojiResult$2 === void 0 ? void 0 : (_topEmojiResult$2$val = _topEmojiResult$2.values[0]) === null || _topEmojiResult$2$val === void 0 ? void 0 : _topEmojiResult$2$val[0]) || '??';\n      receivedMostReactionsFrom = {\n        name,\n        count,\n        emoji\n      };\n    }\n\n    // KPI: Most Popular Message\n    const popularMessageQuery = `\n      WITH numbered_reactions AS (\n        SELECT\n          messageId,\n          ROW_NUMBER() OVER(PARTITION BY fromId, messageId ORDER BY messageReceivedAt DESC) as rn\n        FROM reactions\n        WHERE emoji IS NOT NULL AND emoji != ''\n      )\n      SELECT\n        nr.messageId,\n        m.body,\n        COUNT(*) as reaction_count\n      FROM numbered_reactions nr\n      JOIN messages m ON nr.messageId = m.id\n      WHERE nr.rn = 1\n        AND m.sourceServiceId = '${userServiceId}'\n        AND m.body IS NOT NULL AND m.body != ''\n      GROUP BY nr.messageId, m.body\n      ORDER BY reaction_count DESC\n      LIMIT 1;\n    `;\n    const popularMessageResult = db.exec(popularMessageQuery);\n    let mostPopularMessage = null;\n    if ((_popularMessageResult = popularMessageResult[0]) !== null && _popularMessageResult !== void 0 && _popularMessageResult.values[0]) {\n      const messageId = popularMessageResult[0].values[0][0];\n      const text = popularMessageResult[0].values[0][1];\n      const reactionCount = popularMessageResult[0].values[0][2];\n      const reactionsForMessageQuery = `\n        WITH numbered_reactions AS (\n          SELECT\n            emoji,\n            fromId,\n            ROW_NUMBER() OVER(PARTITION BY fromId, messageId ORDER BY messageReceivedAt DESC) as rn\n          FROM reactions\n          WHERE messageId = '${messageId}' AND emoji IS NOT NULL AND emoji != ''\n        )\n        SELECT\n          nr.emoji,\n          c.profileFullName as sender_name\n        FROM numbered_reactions nr\n        JOIN conversations c ON nr.fromId = c.id\n        WHERE nr.rn = 1;\n      `;\n      const reactionsForMessageResult = db.exec(reactionsForMessageQuery);\n      const reactions = reactionsForMessageResult[0] ? reactionsForMessageResult[0].values.map(row => ({\n        emoji: row[0],\n        sender: row[1]\n      })) : [];\n      mostPopularMessage = {\n        text,\n        reactionCount,\n        reactions\n      };\n    }\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent,\n      reactedToMost,\n      receivedMostReactionsFrom,\n      mostPopularMessage\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\nexport async function loadUsers(dbBuffer, key) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function loadIndividualStats(dbBuffer, key, userId) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}","map":{"version":3,"names":["CryptoJS","sqlJsInstance","sqlJsInitPromise","getSqlJs","SQLModule","wasmBinary","Promise","all","fetch","then","res","ok","Error","statusText","arrayBuffer","initSqlJs","default","SQL","err","console","error","initializeSQL","createDatabaseFromBuffer","dbBuffer","Database","Uint8Array","decryptDatabase","encrypted","password","keyHex","substring","key","enc","Hex","parse","iv","lib","WordArray","create","slice","ciphertext","decrypted","AES","decrypt","mode","CBC","padding","pad","Pkcs7","decryptedBytes","toString","Latin1","decryptedArray","length","i","charCodeAt","buffer","loadDatabase","conversationIds","sqliteHeader","fileHeader","isDecrypted","every","byte","processDatabase","decryptedBuffer","_mostMessagesSent$","_mostReactionsGiven$","_mostReactionsReceive","_mostMentioned$","_mostRepliedTo$","_mostMediaSent$","db","buildWhereClause","tableAlias","idColumn","prefix","ids","map","id","join","messagesWhereClause","reactionsWhereClause","conversationsWhereClause","undefined","messagesJoinWhereClause","analytics","all_conversations","message_counts","by_day","by_hour","top_conversations","kpis","total_messages","total_conversations","avg_messages_per_day","reactions","total_reactions","top_emojis","top_emojis_by_author","awards","most_messages_sent","winner","count","most_reactions_given","most_reactions_received","most_mentioned","most_replied_to","most_media_sent","funniestUsers","userNamesById","nameMappingQuery","nameMappingResults","exec","values","forEach","serviceId","profileFullName","profileName","name","trim","log","allConvosResults","byDayResults","byHourResults","topConvoResults","kpiResults","reactionResults","mostMessagesSentQuery","mostReactionsGivenQuery","mostReactionsReceivedQuery","mostMentionedQuery","mostRepliedToQuery","mostMediaSentQuery","mostMessagesSent","mostReactionsGiven","mostReactionsReceived","mostMentioned","mostRepliedTo","mostMediaSent","Object","fromEntries","keys","Math","round","emojiCounts","authorEmojiCounts","emoji","fromId","entries","sort","a","b","authorId","laughEmojis","funniestUsersQuery","e","funniestUsersResults","row","totalLaughReacts","totalLaughRate","humorScore","getUsers","_messageSendersResult","_reactionGiversResult","_reactionReceiversRes","nameMap","Map","set","messageSendersQuery","messageSendersResult","messageSenders","reactionGiversQuery","reactionGiversResult","reactionGivers","reactionReceiversQuery","reactionReceiversResult","reactionReceivers","allUserIds","Set","uniqueUserIds","Array","from","filter","usersWithPotentialDuplicates","get","uniqueUsersByName","user","has","users","localeCompare","getIndividualStats","userId","_getIdsResult$","_getIdsResult$$values","_getIdsResult$2","_getIdsResult$2$value","_totalMessagesResult$","_totalMessagesResult$2","_timestampsResult$","_totalReactionsResult","_totalReactionsResult2","_reactedToMostResult$","_receivedMostResult$","_popularMessageResult","getIdsQuery","getIdsResult","userUUID","userServiceId","totalMessagesQuery","totalMessagesResult","totalMessagesSent","allTimestampsQuery","timestampsResult","mostPopularDay","dayCounts","fill","ts","date","Date","getDay","maxCount","max","popularDayIndex","indexOf","dayMap","totalReactionsQuery","totalReactionsResult","totalReactionsSent","reactedToMostQuery","reactedToMostResult","reactedToMost","_topEmojiResult$","_topEmojiResult$$valu","targetSvcId","topEmojiQuery","topEmojiResult","receivedMostQuery","receivedMostResult","receivedMostReactionsFrom","_topEmojiResult$2","_topEmojiResult$2$val","popularMessageQuery","popularMessageResult","mostPopularMessage","messageId","text","reactionCount","reactionsForMessageQuery","reactionsForMessageResult","sender","loadUsers","loadIndividualStats"],"sources":["E:/ahste/Projects/signal-analytics/frontend/src/utils/database.ts"],"sourcesContent":["/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance: any = null;\nlet sqlJsInitPromise: Promise<any> | null = null;\n\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([\n          import('sql.js'),\n          fetch('/sql-wasm.wasm').then(res => {\n            if (!res.ok) {\n              throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n            }\n            return res.arrayBuffer();\n          })\n        ]);\n\n        const initSqlJs = SQLModule.default as unknown as (config: any) => Promise<any>;\n        const SQL = await initSqlJs({ wasmBinary });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\n\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer: ArrayBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\n\nexport interface Conversation {\n  id: string;\n  name: string;\n}\n\nexport interface Award {\n  winner: string | null;\n  count: number;\n}\n\nexport interface FunniestUserData {\n  name: string;\n  totalLaughReacts: number;\n  totalLaughRate: number;\n  humorScore: number;\n}\n\nexport interface AnalyticsData {\n  all_conversations: Conversation[];\n  message_counts: {\n    by_day: Record<string, number>;\n    by_hour: Record<string, number>;\n  };\n  top_conversations: {\n    name: string;\n    count: number;\n  }[];\n  kpis: {\n    total_messages: number;\n    total_conversations: number;\n    avg_messages_per_day: number;\n  };\n  reactions: {\n    total_reactions: number;\n    top_emojis: { emoji: string; count: number }[];\n    top_emojis_by_author: Record<string, { emoji: string; count: number }[]>;\n  };\n  awards: {\n    most_messages_sent: Award;\n    most_reactions_given: Award;\n    most_reactions_received: Award;\n    most_mentioned: Award;\n    most_replied_to: Award;\n    most_media_sent: Award;\n  };\n  funniestUsers: FunniestUserData[];\n}\n\nexport async function decryptDatabase(\n  encrypted: ArrayBuffer,\n  password: string\n): Promise<ArrayBuffer> {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt(\n      { ciphertext: ciphertext } as any,\n      key,\n      {\n        iv: iv,\n        mode: CryptoJS.mode.CBC,\n        padding: CryptoJS.pad.Pkcs7,\n      }\n    );\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(\n  dbBuffer: ArrayBuffer,\n  key?: string,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00, // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n\n  const isDecrypted =\n    fileHeader.length === sqliteHeader.length &&\n    fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function processDatabase(\n  dbBuffer: ArrayBuffer,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias?: string, idColumn: string = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n\n    const analytics: AnalyticsData & { userNamesById: Record<string, string> } = {\n      all_conversations: [],\n      message_counts: { by_day: {}, by_hour: {} },\n      top_conversations: [],\n      kpis: { total_messages: 0, total_conversations: 0, avg_messages_per_day: 0 },\n      reactions: { total_reactions: 0, top_emojis: [], top_emojis_by_author: {} },\n      awards: {\n        most_messages_sent: { winner: null, count: 0 },\n        most_reactions_given: { winner: null, count: 0 },\n        most_reactions_received: { winner: null, count: 0 },\n        most_mentioned: { winner: null, count: 0 },\n        most_replied_to: { winner: null, count: 0 },\n        most_media_sent: { winner: null, count: 0 },\n      },\n      funniestUsers: [],\n      userNamesById: {},\n    };\n\n    // Build user ID to name mapping from conversations\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]: [string, string, string, string]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) analytics.userNamesById[id] = name;\n          if (serviceId) analytics.userNamesById[serviceId] = name;\n        }\n      });\n    }\n    console.log('Constructed userNamesById mapping:', analytics.userNamesById);\n\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]: [string, string]) => ({ id, name }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id JOIN conversations c ON mn.mentionAci = c.serviceId ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostRepliedToQuery = `SELECT json_extract(m.json, '$.quote.author') as repliedToAuthor, COUNT(*) as count FROM messages m ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} json_extract(m.json, '$.quote.author') IS NOT NULL GROUP BY repliedToAuthor ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostRepliedTo, mostMediaSent] = [\n      db.exec(mostMessagesSentQuery),\n      db.exec(mostReactionsGivenQuery),\n      db.exec(mostReactionsReceivedQuery),\n      db.exec(mostMentionedQuery),\n      db.exec(mostRepliedToQuery),\n      db.exec(mostMediaSentQuery),\n    ];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]: [string, number]) => ({ name, count }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0] as [number, number];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0,\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts: Record<string, number> = {};\n      const authorEmojiCounts: Record<string, Record<string, number>> = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]: [string, string, number]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({ emoji, count }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({ emoji, count }));\n      }\n    }\n\n    // Process Award Results\n    if (mostMessagesSent[0]?.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0] as [string, number];\n      analytics.awards.most_messages_sent = { winner, count };\n    }\n    if (mostReactionsGiven[0]?.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0] as [string, number];\n      analytics.awards.most_reactions_given = { winner, count };\n    }\n    if (mostReactionsReceived[0]?.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0] as [string, number];\n      analytics.awards.most_reactions_received = { winner, count };\n    }\n    if (mostMentioned[0]?.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0] as [string, number];\n      analytics.awards.most_mentioned = { winner, count };\n    }\n    if (mostRepliedTo[0]?.values[0]) {\n      const [winner, count] = mostRepliedTo[0].values[0] as [string, number];\n      analytics.awards.most_replied_to = { winner, count };\n    }\n    if (mostMediaSent[0]?.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0] as [string, number];\n      analytics.awards.most_media_sent = { winner, count };\n    }\n\n    // KPI: Funniest Users\n    const laughEmojis = ['😂', '🤣', '😆', '😄'];\n    const funniestUsersQuery = `\n      WITH user_message_counts AS (\n        SELECT sourceServiceId, COUNT(*) as total_messages_sent\n        FROM messages\n        GROUP BY sourceServiceId\n      ),\n      latest_laugh_reactions AS (\n        SELECT\n          messageId, targetAuthorAci, emoji,\n          ROW_NUMBER() OVER(PARTITION BY fromId, messageId ORDER BY messageReceivedAt DESC) as rn\n        FROM reactions\n        WHERE emoji IN (${laughEmojis.map(e => `'${e}'`).join(',')})\n      ),\n      user_laugh_reacts_received AS (\n        SELECT targetAuthorAci, COUNT(*) as total_laugh_reacts\n        FROM latest_laugh_reactions\n        WHERE rn = 1\n        GROUP BY targetAuthorAci\n      ),\n      messages_with_laugh_reacts AS (\n        SELECT targetAuthorAci, COUNT(DISTINCT messageId) as num_messages_with_laughs\n        FROM latest_laugh_reactions\n        WHERE rn = 1\n        GROUP BY targetAuthorAci\n      )\n      SELECT\n        c.profileFullName as name,\n        COALESCE(ulrr.total_laugh_reacts, 0) as total_laugh_reacts,\n        CASE\n          WHEN umc.total_messages_sent > 0 THEN CAST(COALESCE(ulrr.total_laugh_reacts, 0) AS REAL) / umc.total_messages_sent\n          ELSE 0\n        END as total_laugh_rate,\n        CASE\n          WHEN mwlr.num_messages_with_laughs > 0 THEN CAST(COALESCE(ulrr.total_laugh_reacts, 0) AS REAL) / mwlr.num_messages_with_laughs\n          ELSE 0\n        END as humor_score\n      FROM conversations c\n      LEFT JOIN user_message_counts umc ON c.serviceId = umc.sourceServiceId\n      LEFT JOIN user_laugh_reacts_received ulrr ON c.serviceId = ulrr.targetAuthorAci\n      LEFT JOIN messages_with_laugh_reacts mwlr ON c.serviceId = mwlr.targetAuthorAci\n      WHERE c.type = 'private' AND c.serviceId IS NOT NULL AND umc.total_messages_sent > 0\n      ORDER BY humor_score DESC;\n    `;\n    const funniestUsersResults = db.exec(funniestUsersQuery);\n    const funniestUsers: FunniestUserData[] = funniestUsersResults[0]\n      ? funniestUsersResults[0].values.map((row: any) => ({\n          name: row[0],\n          totalLaughReacts: row[1],\n          totalLaughRate: row[2],\n          humorScore: row[3],\n        }))\n      : [];\n    analytics.funniestUsers = funniestUsers;\n\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface IndividualStatsData {\n  totalMessagesSent: number;\n  mostPopularDay: string;\n  totalReactionsSent: number;\n  reactedToMost: {\n    name: string;\n    count: number;\n    emoji: string;\n  } | null;\n  receivedMostReactionsFrom: {\n    name: string;\n    count: number;\n    emoji: string;\n  } | null;\n  mostPopularMessage: {\n    text: string | null;\n    reactionCount: number;\n    reactions: {\n      emoji: string;\n      sender: string;\n    }[];\n  } | null;\n}\n\nexport async function getUsers(dbBuffer: ArrayBuffer): Promise<User[]> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Build a comprehensive name mapping from the conversations table\n    const nameMap = new Map<string, string>();\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]: [string, string, string, string]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) nameMap.set(id, name);\n          if (serviceId) nameMap.set(serviceId, name);\n        }\n      });\n    }\n\n    // Collect all unique user IDs from messages and reactions\n    const messageSendersQuery = `SELECT DISTINCT sourceServiceId FROM messages WHERE sourceServiceId IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = messageSendersResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = reactionGiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = reactionReceiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n    const uniqueUserIds = Array.from(new Set(allUserIds.filter(id => typeof id === 'string' && id)));\n\n    // Create the User[] array, using the name map\n    const usersWithPotentialDuplicates: User[] = uniqueUserIds\n      .map(id => ({\n        id,\n        name: nameMap.get(id) || id, // Use mapped name, fallback to ID\n      }));\n\n    // Deduplicate users by name, keeping the first occurrence\n    const uniqueUsersByName = new Map<string, User>();\n    for (const user of usersWithPotentialDuplicates) {\n      if (!uniqueUsersByName.has(user.name)) {\n        uniqueUsersByName.set(user.name, user);\n      }\n    }\n\n    const users = Array.from(uniqueUsersByName.values())\n      .sort((a, b) => a.name.localeCompare(b.name));\n\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\n\n\nexport async function getIndividualStats(dbBuffer: ArrayBuffer, userId: string): Promise<IndividualStatsData> {\n  if (!userId) {\n    throw new Error('User ID is required to get individual stats.');\n  }\n\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Find the canonical serviceId AND id for the given user ID\n    const getIdsQuery = `SELECT id, serviceId FROM conversations WHERE id = '${userId}' OR serviceId = '${userId}' LIMIT 1`;\n    const getIdsResult = db.exec(getIdsQuery);\n    const userUUID = getIdsResult[0]?.values[0]?.[0] as string || userId;\n    const userServiceId = getIdsResult[0]?.values[0]?.[1] as string || userId;\n\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = totalMessagesResult[0]?.values[0]?.[0] as number || 0;\n\n    // Calculate most popular day in JS for robustness\n    const allTimestampsQuery = `SELECT sent_at FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const timestampsResult = db.exec(allTimestampsQuery);\n    let mostPopularDay = 'N/A';\n    if (timestampsResult[0]?.values.length > 0) {\n      const dayCounts = Array(7).fill(0); // Sunday - Saturday\n      timestampsResult[0].values.forEach((row: any[]) => {\n        const ts = row[0] as number;\n        const date = new Date(ts);\n        dayCounts[date.getDay()]++;\n      });\n      const maxCount = Math.max(...dayCounts);\n      const popularDayIndex = dayCounts.indexOf(maxCount);\n      const dayMap = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n      mostPopularDay = dayMap[popularDayIndex];\n    }\n\n    // Use the user's UUID (conversations.id) for reactions, as per the user's view\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userUUID}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = totalReactionsResult[0]?.values[0]?.[0] as number || 0;\n\n    // KPI: Reacted To Most\n    const reactedToMostQuery = `\n      SELECT r.targetAuthorAci, c.profileFullName, COUNT(*) as count\n      FROM reactions r\n      JOIN conversations c ON r.targetAuthorAci = c.serviceId\n      WHERE r.fromId = '${userUUID}'\n      GROUP BY r.targetAuthorAci, c.profileFullName\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const reactedToMostResult = db.exec(reactedToMostQuery);\n    let reactedToMost = null;\n    if (reactedToMostResult[0]?.values[0]) {\n      const targetSvcId = reactedToMostResult[0].values[0][0] as string;\n      const name = reactedToMostResult[0].values[0][1] as string;\n      const count = reactedToMostResult[0].values[0][2] as number;\n\n      const topEmojiQuery = `\n        SELECT emoji, COUNT(*) as count\n        FROM reactions\n        WHERE fromId = '${userUUID}' AND targetAuthorAci = '${targetSvcId}'\n        GROUP BY emoji\n        ORDER BY count DESC\n        LIMIT 1;\n      `;\n      const topEmojiResult = db.exec(topEmojiQuery);\n      const emoji = topEmojiResult[0]?.values[0]?.[0] as string || '??';\n      reactedToMost = { name, count, emoji };\n    }\n\n    // KPI: Received Most Reactions From\n    const receivedMostQuery = `\n      SELECT r.fromId, c.profileFullName, COUNT(*) as count\n      FROM reactions r\n      JOIN conversations c ON r.fromId = c.id\n      WHERE r.targetAuthorAci = '${userServiceId}'\n      GROUP BY r.fromId, c.profileFullName\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const receivedMostResult = db.exec(receivedMostQuery);\n    let receivedMostReactionsFrom = null;\n    if (receivedMostResult[0]?.values[0]) {\n      const fromId = receivedMostResult[0].values[0][0] as string;\n      const name = receivedMostResult[0].values[0][1] as string;\n      const count = receivedMostResult[0].values[0][2] as number;\n\n      const topEmojiQuery = `\n        SELECT emoji, COUNT(*) as count\n        FROM reactions\n        WHERE fromId = '${fromId}' AND targetAuthorAci = '${userServiceId}'\n        GROUP BY emoji\n        ORDER BY count DESC\n        LIMIT 1;\n      `;\n      const topEmojiResult = db.exec(topEmojiQuery);\n      const emoji = topEmojiResult[0]?.values[0]?.[0] as string || '??';\n      receivedMostReactionsFrom = { name, count, emoji };\n    }\n\n    // KPI: Most Popular Message\n    const popularMessageQuery = `\n      WITH numbered_reactions AS (\n        SELECT\n          messageId,\n          ROW_NUMBER() OVER(PARTITION BY fromId, messageId ORDER BY messageReceivedAt DESC) as rn\n        FROM reactions\n        WHERE emoji IS NOT NULL AND emoji != ''\n      )\n      SELECT\n        nr.messageId,\n        m.body,\n        COUNT(*) as reaction_count\n      FROM numbered_reactions nr\n      JOIN messages m ON nr.messageId = m.id\n      WHERE nr.rn = 1\n        AND m.sourceServiceId = '${userServiceId}'\n        AND m.body IS NOT NULL AND m.body != ''\n      GROUP BY nr.messageId, m.body\n      ORDER BY reaction_count DESC\n      LIMIT 1;\n    `;\n    const popularMessageResult = db.exec(popularMessageQuery);\n    let mostPopularMessage = null;\n    if (popularMessageResult[0]?.values[0]) {\n      const messageId = popularMessageResult[0].values[0][0] as string;\n      const text = popularMessageResult[0].values[0][1] as string | null;\n      const reactionCount = popularMessageResult[0].values[0][2] as number;\n\n      const reactionsForMessageQuery = `\n        WITH numbered_reactions AS (\n          SELECT\n            emoji,\n            fromId,\n            ROW_NUMBER() OVER(PARTITION BY fromId, messageId ORDER BY messageReceivedAt DESC) as rn\n          FROM reactions\n          WHERE messageId = '${messageId}' AND emoji IS NOT NULL AND emoji != ''\n        )\n        SELECT\n          nr.emoji,\n          c.profileFullName as sender_name\n        FROM numbered_reactions nr\n        JOIN conversations c ON nr.fromId = c.id\n        WHERE nr.rn = 1;\n      `;\n      const reactionsForMessageResult = db.exec(reactionsForMessageQuery);\n      const reactions = reactionsForMessageResult[0] ? reactionsForMessageResult[0].values.map((row: any) => ({ emoji: row[0], sender: row[1] })) : [];\n      mostPopularMessage = { text, reactionCount, reactions };\n    }\n\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent,\n      reactedToMost,\n      receivedMostReactionsFrom,\n      mostPopularMessage,\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\n\nexport async function loadUsers(\n  dbBuffer: ArrayBuffer,\n  key?: string\n): Promise<User[]> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function loadIndividualStats(\n  dbBuffer: ArrayBuffer,\n  key: string | undefined,\n  userId: string\n): Promise<IndividualStatsData> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}