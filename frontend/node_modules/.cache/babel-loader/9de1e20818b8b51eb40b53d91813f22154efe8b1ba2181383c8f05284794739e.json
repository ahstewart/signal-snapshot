{"ast":null,"code":"/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance = null;\nlet sqlJsInitPromise = null;\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([import('sql.js'), fetch('/sql-wasm.wasm').then(res => {\n          if (!res.ok) {\n            throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n          }\n          return res.arrayBuffer();\n        })]);\n        const initSqlJs = SQLModule.default;\n        const SQL = await initSqlJs({\n          wasmBinary\n        });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\nexport async function decryptDatabase(encrypted, password) {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt({\n      ciphertext: ciphertext\n    }, key, {\n      iv: iv,\n      mode: CryptoJS.mode.CBC,\n      padding: CryptoJS.pad.Pkcs7\n    });\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(dbBuffer, key, conversationIds) {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00 // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function processDatabase(dbBuffer, conversationIds) {\n  try {\n    var _mostMessagesSent$, _mostReactionsGiven$, _mostReactionsReceive, _mostMentioned$, _mostEggplantsSent$, _mostMediaSent$;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias, idColumn = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n    const analytics = {\n      all_conversations: [],\n      message_counts: {\n        by_day: {},\n        by_hour: {}\n      },\n      top_conversations: [],\n      kpis: {\n        total_messages: 0,\n        total_conversations: 0,\n        avg_messages_per_day: 0\n      },\n      reactions: {\n        total_reactions: 0,\n        top_emojis: [],\n        top_emojis_by_author: {}\n      },\n      awards: {\n        most_messages_sent: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_given: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_received: {\n          winner: null,\n          count: 0\n        },\n        most_mentioned: {\n          winner: null,\n          count: 0\n        },\n        most_eggplants_sent: {\n          winner: null,\n          count: 0\n        },\n        most_media_sent: {\n          winner: null,\n          count: 0\n        }\n      },\n      userNamesById: {}\n    };\n\n    // Build user ID to profileFullName mapping\n    const userNameResults = db.exec(`SELECT serviceId, profileFullName FROM conversations WHERE serviceId IS NOT NULL AND profileFullName IS NOT NULL`);\n    if (userNameResults[0]) {\n      userNameResults[0].values.forEach(([serviceId, profileFullName]) => {\n        analytics.userNamesById[serviceId] = profileFullName;\n      });\n    }\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]) => ({\n          id,\n          name\n        }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostEggplantsSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} body LIKE '%🍆%' AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostEggplantsSent, mostMediaSent] = [db.exec(mostMessagesSentQuery), db.exec(mostReactionsGivenQuery), db.exec(mostReactionsReceivedQuery), db.exec(mostMentionedQuery), db.exec(mostEggplantsSentQuery), db.exec(mostMediaSentQuery)];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]) => ({\n      name,\n      count\n    }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts = {};\n      const authorEmojiCounts = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({\n        emoji,\n        count\n      }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({\n          emoji,\n          count\n        }));\n      }\n    }\n\n    // Process Award Results\n    if ((_mostMessagesSent$ = mostMessagesSent[0]) !== null && _mostMessagesSent$ !== void 0 && _mostMessagesSent$.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0];\n      analytics.awards.most_messages_sent = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsGiven$ = mostReactionsGiven[0]) !== null && _mostReactionsGiven$ !== void 0 && _mostReactionsGiven$.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0];\n      analytics.awards.most_reactions_given = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsReceive = mostReactionsReceived[0]) !== null && _mostReactionsReceive !== void 0 && _mostReactionsReceive.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0];\n      analytics.awards.most_reactions_received = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMentioned$ = mostMentioned[0]) !== null && _mostMentioned$ !== void 0 && _mostMentioned$.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0];\n      analytics.awards.most_mentioned = {\n        winner,\n        count\n      };\n    }\n    if ((_mostEggplantsSent$ = mostEggplantsSent[0]) !== null && _mostEggplantsSent$ !== void 0 && _mostEggplantsSent$.values[0]) {\n      const [winner, count] = mostEggplantsSent[0].values[0];\n      analytics.awards.most_eggplants_sent = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMediaSent$ = mostMediaSent[0]) !== null && _mostMediaSent$ !== void 0 && _mostMediaSent$.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0];\n      analytics.awards.most_media_sent = {\n        winner,\n        count\n      };\n    }\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\nexport async function getUsers(dbBuffer) {\n  try {\n    var _messageSendersResult, _reactionGiversResult, _reactionReceiversRes;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const messageSendersQuery = `SELECT DISTINCT source FROM messages WHERE source IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = ((_messageSendersResult = messageSendersResult[0]) === null || _messageSendersResult === void 0 ? void 0 : _messageSendersResult.values.map(([id]) => id)) || [];\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = ((_reactionGiversResult = reactionGiversResult[0]) === null || _reactionGiversResult === void 0 ? void 0 : _reactionGiversResult.values.map(([id]) => id)) || [];\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = ((_reactionReceiversRes = reactionReceiversResult[0]) === null || _reactionReceiversRes === void 0 ? void 0 : _reactionReceiversRes.values.map(([id]) => id)) || [];\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n    const uniqueUserIds = Array.from(new Set(allUserIds.filter(id => typeof id === 'string' && id)));\n    const users = uniqueUserIds.map(id => ({\n      id,\n      name: id\n    })).sort((a, b) => a.name.localeCompare(b.name));\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\nexport async function getIndividualStats(dbBuffer, userId) {\n  try {\n    var _totalMessagesResult$, _totalMessagesResult$2, _popularDayResult$, _popularDayResult$$va, _totalReactionsResult, _totalReactionsResult2;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE source = '${userId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = ((_totalMessagesResult$ = totalMessagesResult[0]) === null || _totalMessagesResult$ === void 0 ? void 0 : (_totalMessagesResult$2 = _totalMessagesResult$.values[0]) === null || _totalMessagesResult$2 === void 0 ? void 0 : _totalMessagesResult$2[0]) || 0;\n    const popularDayQuery = `\n      SELECT\n        CASE CAST(strftime('%w', sent_at/1000, 'unixepoch') AS INTEGER)\n          WHEN 0 THEN 'Sunday'\n          WHEN 1 THEN 'Monday'\n          WHEN 2 THEN 'Tuesday'\n          WHEN 3 THEN 'Wednesday'\n          WHEN 4 THEN 'Thursday'\n          WHEN 5 THEN 'Friday'\n          ELSE 'Saturday'\n        END as day,\n        COUNT(*) as count\n      FROM messages\n      WHERE source = '${userId}'\n      GROUP BY day\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const popularDayResult = db.exec(popularDayQuery);\n    const mostPopularDay = ((_popularDayResult$ = popularDayResult[0]) === null || _popularDayResult$ === void 0 ? void 0 : (_popularDayResult$$va = _popularDayResult$.values[0]) === null || _popularDayResult$$va === void 0 ? void 0 : _popularDayResult$$va[0]) || 'N/A';\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userId}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = ((_totalReactionsResult = totalReactionsResult[0]) === null || _totalReactionsResult === void 0 ? void 0 : (_totalReactionsResult2 = _totalReactionsResult.values[0]) === null || _totalReactionsResult2 === void 0 ? void 0 : _totalReactionsResult2[0]) || 0;\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\nexport async function loadUsers(dbBuffer, key) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function loadIndividualStats(dbBuffer, key, userId) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}","map":{"version":3,"names":["CryptoJS","sqlJsInstance","sqlJsInitPromise","getSqlJs","SQLModule","wasmBinary","Promise","all","fetch","then","res","ok","Error","statusText","arrayBuffer","initSqlJs","default","SQL","err","console","error","initializeSQL","createDatabaseFromBuffer","dbBuffer","Database","Uint8Array","decryptDatabase","encrypted","password","keyHex","substring","key","enc","Hex","parse","iv","lib","WordArray","create","slice","ciphertext","decrypted","AES","decrypt","mode","CBC","padding","pad","Pkcs7","decryptedBytes","toString","Latin1","decryptedArray","length","i","charCodeAt","buffer","loadDatabase","conversationIds","sqliteHeader","fileHeader","isDecrypted","every","byte","processDatabase","decryptedBuffer","_mostMessagesSent$","_mostReactionsGiven$","_mostReactionsReceive","_mostMentioned$","_mostEggplantsSent$","_mostMediaSent$","db","buildWhereClause","tableAlias","idColumn","prefix","ids","map","id","join","messagesWhereClause","reactionsWhereClause","conversationsWhereClause","undefined","messagesJoinWhereClause","analytics","all_conversations","message_counts","by_day","by_hour","top_conversations","kpis","total_messages","total_conversations","avg_messages_per_day","reactions","total_reactions","top_emojis","top_emojis_by_author","awards","most_messages_sent","winner","count","most_reactions_given","most_reactions_received","most_mentioned","most_eggplants_sent","most_media_sent","userNamesById","userNameResults","exec","values","forEach","serviceId","profileFullName","allConvosResults","name","byDayResults","byHourResults","topConvoResults","kpiResults","reactionResults","mostMessagesSentQuery","mostReactionsGivenQuery","mostReactionsReceivedQuery","mostMentionedQuery","mostEggplantsSentQuery","mostMediaSentQuery","mostMessagesSent","mostReactionsGiven","mostReactionsReceived","mostMentioned","mostEggplantsSent","mostMediaSent","Object","fromEntries","keys","Math","round","emojiCounts","authorEmojiCounts","emoji","fromId","entries","sort","a","b","authorId","getUsers","_messageSendersResult","_reactionGiversResult","_reactionReceiversRes","messageSendersQuery","messageSendersResult","messageSenders","reactionGiversQuery","reactionGiversResult","reactionGivers","reactionReceiversQuery","reactionReceiversResult","reactionReceivers","allUserIds","Set","uniqueUserIds","Array","from","filter","users","localeCompare","getIndividualStats","userId","_totalMessagesResult$","_totalMessagesResult$2","_popularDayResult$","_popularDayResult$$va","_totalReactionsResult","_totalReactionsResult2","totalMessagesQuery","totalMessagesResult","totalMessagesSent","popularDayQuery","popularDayResult","mostPopularDay","totalReactionsQuery","totalReactionsResult","totalReactionsSent","loadUsers","loadIndividualStats"],"sources":["E:/ahste/Projects/signal-analytics/frontend/src/utils/database.ts"],"sourcesContent":["/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance: any = null;\nlet sqlJsInitPromise: Promise<any> | null = null;\n\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([\n          import('sql.js'),\n          fetch('/sql-wasm.wasm').then(res => {\n            if (!res.ok) {\n              throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n            }\n            return res.arrayBuffer();\n          })\n        ]);\n\n        const initSqlJs = SQLModule.default as unknown as (config: any) => Promise<any>;\n        const SQL = await initSqlJs({ wasmBinary });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\n\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer: ArrayBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\n\nexport interface Conversation {\n  id: string;\n  name: string;\n}\n\nexport interface Award {\n  winner: string | null;\n  count: number;\n}\n\nexport interface AnalyticsData {\n  all_conversations: Conversation[];\n  message_counts: {\n    by_day: Record<string, number>;\n    by_hour: Record<string, number>;\n  };\n  top_conversations: {\n    name: string;\n    count: number;\n  }[];\n  kpis: {\n    total_messages: number;\n    total_conversations: number;\n    avg_messages_per_day: number;\n  };\n  reactions: {\n    total_reactions: number;\n    top_emojis: { emoji: string; count: number }[];\n    top_emojis_by_author: Record<string, { emoji: string; count: number }[]>;\n  };\n  awards: {\n    most_messages_sent: Award;\n    most_reactions_given: Award;\n    most_reactions_received: Award;\n    most_mentioned: Award;\n    most_eggplants_sent: Award;\n    most_media_sent: Award;\n  };\n}\n\nexport async function decryptDatabase(\n  encrypted: ArrayBuffer,\n  password: string\n): Promise<ArrayBuffer> {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt(\n      { ciphertext: ciphertext } as any,\n      key,\n      {\n        iv: iv,\n        mode: CryptoJS.mode.CBC,\n        padding: CryptoJS.pad.Pkcs7,\n      }\n    );\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(\n  dbBuffer: ArrayBuffer,\n  key?: string,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00, // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n\n  const isDecrypted =\n    fileHeader.length === sqliteHeader.length &&\n    fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function processDatabase(\n  dbBuffer: ArrayBuffer,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias?: string, idColumn: string = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n\n    const analytics: AnalyticsData & { userNamesById?: Record<string, string> } = {\n      all_conversations: [],\n      message_counts: { by_day: {}, by_hour: {} },\n      top_conversations: [],\n      kpis: { total_messages: 0, total_conversations: 0, avg_messages_per_day: 0 },\n      reactions: { total_reactions: 0, top_emojis: [], top_emojis_by_author: {} },\n      awards: {\n        most_messages_sent: { winner: null, count: 0 },\n        most_reactions_given: { winner: null, count: 0 },\n        most_reactions_received: { winner: null, count: 0 },\n        most_mentioned: { winner: null, count: 0 },\n        most_eggplants_sent: { winner: null, count: 0 },\n        most_media_sent: { winner: null, count: 0 },\n      },\n      userNamesById: {},\n    };\n\n    // Build user ID to profileFullName mapping\n    const userNameResults = db.exec(`SELECT serviceId, profileFullName FROM conversations WHERE serviceId IS NOT NULL AND profileFullName IS NOT NULL`);\n    if (userNameResults[0]) {\n      userNameResults[0].values.forEach(([serviceId, profileFullName]: [string, string]) => {\n        analytics.userNamesById![serviceId] = profileFullName;\n      });\n    }\n\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]: [string, string]) => ({ id, name }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostEggplantsSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} body LIKE '%🍆%' AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT source, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND source IS NOT NULL GROUP BY source ORDER BY count DESC LIMIT 1`;\n\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostEggplantsSent, mostMediaSent] = [\n      db.exec(mostMessagesSentQuery),\n      db.exec(mostReactionsGivenQuery),\n      db.exec(mostReactionsReceivedQuery),\n      db.exec(mostMentionedQuery),\n      db.exec(mostEggplantsSentQuery),\n      db.exec(mostMediaSentQuery),\n    ];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]: [string, number]) => ({ name, count }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0] as [number, number];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0,\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts: Record<string, number> = {};\n      const authorEmojiCounts: Record<string, Record<string, number>> = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]: [string, string, number]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({ emoji, count }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({ emoji, count }));\n      }\n    }\n\n    // Process Award Results\n    if (mostMessagesSent[0]?.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0] as [string, number];\n      analytics.awards.most_messages_sent = { winner, count };\n    }\n    if (mostReactionsGiven[0]?.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0] as [string, number];\n      analytics.awards.most_reactions_given = { winner, count };\n    }\n    if (mostReactionsReceived[0]?.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0] as [string, number];\n      analytics.awards.most_reactions_received = { winner, count };\n    }\n    if (mostMentioned[0]?.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0] as [string, number];\n      analytics.awards.most_mentioned = { winner, count };\n    }\n    if (mostEggplantsSent[0]?.values[0]) {\n      const [winner, count] = mostEggplantsSent[0].values[0] as [string, number];\n      analytics.awards.most_eggplants_sent = { winner, count };\n    }\n    if (mostMediaSent[0]?.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0] as [string, number];\n      analytics.awards.most_media_sent = { winner, count };\n    }\n\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface IndividualStatsData {\n  totalMessagesSent: number;\n  mostPopularDay: string;\n  totalReactionsSent: number;\n}\n\nexport async function getUsers(dbBuffer: ArrayBuffer): Promise<User[]> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const messageSendersQuery = `SELECT DISTINCT source FROM messages WHERE source IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = messageSendersResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = reactionGiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = reactionReceiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n\n    const uniqueUserIds = Array.from(new Set(\n      allUserIds.filter(id => typeof id === 'string' && id)\n    ));\n    const users: User[] = uniqueUserIds\n      .map(id => ({\n        id,\n        name: id,\n      }))\n      .sort((a, b) => a.name.localeCompare(b.name));\n\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\n\nexport async function getIndividualStats(\n  dbBuffer: ArrayBuffer,\n  userId: string\n): Promise<IndividualStatsData> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE source = '${userId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = totalMessagesResult[0]?.values[0]?.[0] as number || 0;\n\n    const popularDayQuery = `\n      SELECT\n        CASE CAST(strftime('%w', sent_at/1000, 'unixepoch') AS INTEGER)\n          WHEN 0 THEN 'Sunday'\n          WHEN 1 THEN 'Monday'\n          WHEN 2 THEN 'Tuesday'\n          WHEN 3 THEN 'Wednesday'\n          WHEN 4 THEN 'Thursday'\n          WHEN 5 THEN 'Friday'\n          ELSE 'Saturday'\n        END as day,\n        COUNT(*) as count\n      FROM messages\n      WHERE source = '${userId}'\n      GROUP BY day\n      ORDER BY count DESC\n      LIMIT 1;\n    `;\n    const popularDayResult = db.exec(popularDayQuery);\n    const mostPopularDay = popularDayResult[0]?.values[0]?.[0] as string || 'N/A';\n\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userId}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = totalReactionsResult[0]?.values[0]?.[0] as number || 0;\n\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent,\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\n\nexport async function loadUsers(\n  dbBuffer: ArrayBuffer,\n  key?: string\n): Promise<User[]> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function loadIndividualStats(\n  dbBuffer: ArrayBuffer,\n  key: string | undefined,\n  userId: string\n): Promise<IndividualStatsData> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}