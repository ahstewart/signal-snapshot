{"ast":null,"code":"/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance = null;\nlet sqlJsInitPromise = null;\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([import('sql.js'), fetch('/sql-wasm.wasm').then(res => {\n          if (!res.ok) {\n            throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n          }\n          return res.arrayBuffer();\n        })]);\n        const initSqlJs = SQLModule.default;\n        const SQL = await initSqlJs({\n          wasmBinary\n        });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\nexport async function decryptDatabase(encrypted, password) {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt({\n      ciphertext: ciphertext\n    }, key, {\n      iv: iv,\n      mode: CryptoJS.mode.CBC,\n      padding: CryptoJS.pad.Pkcs7\n    });\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(dbBuffer, key, conversationIds) {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00 // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function processDatabase(dbBuffer, conversationIds) {\n  try {\n    var _mostMessagesSent$, _mostReactionsGiven$, _mostReactionsReceive, _mostMentioned$, _mostRepliedTo$, _mostMediaSent$;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias, idColumn = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n    const analytics = {\n      all_conversations: [],\n      message_counts: {\n        by_day: {},\n        by_hour: {}\n      },\n      top_conversations: [],\n      kpis: {\n        total_messages: 0,\n        total_conversations: 0,\n        avg_messages_per_day: 0\n      },\n      reactions: {\n        total_reactions: 0,\n        top_emojis: [],\n        top_emojis_by_author: {}\n      },\n      awards: {\n        most_messages_sent: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_given: {\n          winner: null,\n          count: 0\n        },\n        most_reactions_received: {\n          winner: null,\n          count: 0\n        },\n        most_mentioned: {\n          winner: null,\n          count: 0\n        },\n        most_replied_to: {\n          winner: null,\n          count: 0\n        },\n        most_media_sent: {\n          winner: null,\n          count: 0\n        }\n      },\n      userNamesById: {}\n    };\n\n    // Build user ID to name mapping from conversations\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) analytics.userNamesById[id] = name;\n          if (serviceId) analytics.userNamesById[serviceId] = name;\n        }\n      });\n    }\n    console.log('Constructed userNamesById mapping:', analytics.userNamesById);\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]) => ({\n          id,\n          name\n        }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id JOIN conversations c ON mn.mentionAci = c.serviceId ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostRepliedToQuery = `SELECT json_extract(m.json, '$.quote.author') as repliedToAuthor, COUNT(*) as count FROM messages m ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} json_extract(m.json, '$.quote.author') IS NOT NULL GROUP BY repliedToAuthor ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostRepliedTo, mostMediaSent] = [db.exec(mostMessagesSentQuery), db.exec(mostReactionsGivenQuery), db.exec(mostReactionsReceivedQuery), db.exec(mostMentionedQuery), db.exec(mostRepliedToQuery), db.exec(mostMediaSentQuery)];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]) => ({\n      name,\n      count\n    }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts = {};\n      const authorEmojiCounts = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({\n        emoji,\n        count\n      }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({\n          emoji,\n          count\n        }));\n      }\n    }\n\n    // Process Award Results\n    if ((_mostMessagesSent$ = mostMessagesSent[0]) !== null && _mostMessagesSent$ !== void 0 && _mostMessagesSent$.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0];\n      analytics.awards.most_messages_sent = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsGiven$ = mostReactionsGiven[0]) !== null && _mostReactionsGiven$ !== void 0 && _mostReactionsGiven$.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0];\n      analytics.awards.most_reactions_given = {\n        winner,\n        count\n      };\n    }\n    if ((_mostReactionsReceive = mostReactionsReceived[0]) !== null && _mostReactionsReceive !== void 0 && _mostReactionsReceive.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0];\n      analytics.awards.most_reactions_received = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMentioned$ = mostMentioned[0]) !== null && _mostMentioned$ !== void 0 && _mostMentioned$.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0];\n      analytics.awards.most_mentioned = {\n        winner,\n        count\n      };\n    }\n    if ((_mostRepliedTo$ = mostRepliedTo[0]) !== null && _mostRepliedTo$ !== void 0 && _mostRepliedTo$.values[0]) {\n      const [winner, count] = mostRepliedTo[0].values[0];\n      analytics.awards.most_replied_to = {\n        winner,\n        count\n      };\n    }\n    if ((_mostMediaSent$ = mostMediaSent[0]) !== null && _mostMediaSent$ !== void 0 && _mostMediaSent$.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0];\n      analytics.awards.most_media_sent = {\n        winner,\n        count\n      };\n    }\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\nexport async function getUsers(dbBuffer) {\n  try {\n    var _messageSendersResult, _reactionGiversResult, _reactionReceiversRes;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Build a comprehensive name mapping from the conversations table\n    const nameMap = new Map();\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) nameMap.set(id, name);\n          if (serviceId) nameMap.set(serviceId, name);\n        }\n      });\n    }\n\n    // Collect all unique user IDs from messages and reactions\n    const messageSendersQuery = `SELECT DISTINCT sourceServiceId FROM messages WHERE sourceServiceId IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = ((_messageSendersResult = messageSendersResult[0]) === null || _messageSendersResult === void 0 ? void 0 : _messageSendersResult.values.map(([id]) => id)) || [];\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = ((_reactionGiversResult = reactionGiversResult[0]) === null || _reactionGiversResult === void 0 ? void 0 : _reactionGiversResult.values.map(([id]) => id)) || [];\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = ((_reactionReceiversRes = reactionReceiversResult[0]) === null || _reactionReceiversRes === void 0 ? void 0 : _reactionReceiversRes.values.map(([id]) => id)) || [];\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n    const uniqueUserIds = Array.from(new Set(allUserIds.filter(id => typeof id === 'string' && id)));\n\n    // Create the User[] array, using the name map\n    const usersWithPotentialDuplicates = uniqueUserIds.map(id => ({\n      id,\n      name: nameMap.get(id) || id // Use mapped name, fallback to ID\n    }));\n\n    // Deduplicate users by name, keeping the first occurrence\n    const uniqueUsersByName = new Map();\n    for (const user of usersWithPotentialDuplicates) {\n      if (!uniqueUsersByName.has(user.name)) {\n        uniqueUsersByName.set(user.name, user);\n      }\n    }\n    const users = Array.from(uniqueUsersByName.values()).sort((a, b) => a.name.localeCompare(b.name));\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\nexport async function getIndividualStats(dbBuffer, userId) {\n  if (!userId) {\n    throw new Error('User ID is required to get individual stats.');\n  }\n  try {\n    var _getIdsResult$, _getIdsResult$$values, _getIdsResult$2, _getIdsResult$2$value, _totalMessagesResult$, _totalMessagesResult$2, _timestampsResult$, _totalReactionsResult, _totalReactionsResult2;\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Find the canonical serviceId AND id for the given user ID\n    const getIdsQuery = `SELECT id, serviceId FROM conversations WHERE id = '${userId}' OR serviceId = '${userId}' LIMIT 1`;\n    const getIdsResult = db.exec(getIdsQuery);\n    const userUUID = ((_getIdsResult$ = getIdsResult[0]) === null || _getIdsResult$ === void 0 ? void 0 : (_getIdsResult$$values = _getIdsResult$.values[0]) === null || _getIdsResult$$values === void 0 ? void 0 : _getIdsResult$$values[0]) || userId;\n    const userServiceId = ((_getIdsResult$2 = getIdsResult[0]) === null || _getIdsResult$2 === void 0 ? void 0 : (_getIdsResult$2$value = _getIdsResult$2.values[0]) === null || _getIdsResult$2$value === void 0 ? void 0 : _getIdsResult$2$value[1]) || userId;\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = ((_totalMessagesResult$ = totalMessagesResult[0]) === null || _totalMessagesResult$ === void 0 ? void 0 : (_totalMessagesResult$2 = _totalMessagesResult$.values[0]) === null || _totalMessagesResult$2 === void 0 ? void 0 : _totalMessagesResult$2[0]) || 0;\n\n    // Calculate most popular day in JS for robustness\n    const allTimestampsQuery = `SELECT sent_at FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const timestampsResult = db.exec(allTimestampsQuery);\n    let mostPopularDay = 'N/A';\n    if (((_timestampsResult$ = timestampsResult[0]) === null || _timestampsResult$ === void 0 ? void 0 : _timestampsResult$.values.length) > 0) {\n      const dayCounts = Array(7).fill(0); // Sunday - Saturday\n      timestampsResult[0].values.forEach(row => {\n        const ts = row[0];\n        const date = new Date(ts);\n        dayCounts[date.getDay()]++;\n      });\n      const maxCount = Math.max(...dayCounts);\n      const popularDayIndex = dayCounts.indexOf(maxCount);\n      const dayMap = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n      mostPopularDay = dayMap[popularDayIndex];\n    }\n\n    // Use the user's UUID (conversations.id) for reactions, as per the user's view\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userUUID}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = ((_totalReactionsResult = totalReactionsResult[0]) === null || _totalReactionsResult === void 0 ? void 0 : (_totalReactionsResult2 = _totalReactionsResult.values[0]) === null || _totalReactionsResult2 === void 0 ? void 0 : _totalReactionsResult2[0]) || 0;\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\nexport async function loadUsers(dbBuffer, key) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\nexport async function loadIndividualStats(dbBuffer, key, userId) {\n  const sqliteHeader = new Uint8Array([0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}","map":{"version":3,"names":["CryptoJS","sqlJsInstance","sqlJsInitPromise","getSqlJs","SQLModule","wasmBinary","Promise","all","fetch","then","res","ok","Error","statusText","arrayBuffer","initSqlJs","default","SQL","err","console","error","initializeSQL","createDatabaseFromBuffer","dbBuffer","Database","Uint8Array","decryptDatabase","encrypted","password","keyHex","substring","key","enc","Hex","parse","iv","lib","WordArray","create","slice","ciphertext","decrypted","AES","decrypt","mode","CBC","padding","pad","Pkcs7","decryptedBytes","toString","Latin1","decryptedArray","length","i","charCodeAt","buffer","loadDatabase","conversationIds","sqliteHeader","fileHeader","isDecrypted","every","byte","processDatabase","decryptedBuffer","_mostMessagesSent$","_mostReactionsGiven$","_mostReactionsReceive","_mostMentioned$","_mostRepliedTo$","_mostMediaSent$","db","buildWhereClause","tableAlias","idColumn","prefix","ids","map","id","join","messagesWhereClause","reactionsWhereClause","conversationsWhereClause","undefined","messagesJoinWhereClause","analytics","all_conversations","message_counts","by_day","by_hour","top_conversations","kpis","total_messages","total_conversations","avg_messages_per_day","reactions","total_reactions","top_emojis","top_emojis_by_author","awards","most_messages_sent","winner","count","most_reactions_given","most_reactions_received","most_mentioned","most_replied_to","most_media_sent","userNamesById","nameMappingQuery","nameMappingResults","exec","values","forEach","serviceId","profileFullName","profileName","name","trim","log","allConvosResults","byDayResults","byHourResults","topConvoResults","kpiResults","reactionResults","mostMessagesSentQuery","mostReactionsGivenQuery","mostReactionsReceivedQuery","mostMentionedQuery","mostRepliedToQuery","mostMediaSentQuery","mostMessagesSent","mostReactionsGiven","mostReactionsReceived","mostMentioned","mostRepliedTo","mostMediaSent","Object","fromEntries","keys","Math","round","emojiCounts","authorEmojiCounts","emoji","fromId","entries","sort","a","b","authorId","getUsers","_messageSendersResult","_reactionGiversResult","_reactionReceiversRes","nameMap","Map","set","messageSendersQuery","messageSendersResult","messageSenders","reactionGiversQuery","reactionGiversResult","reactionGivers","reactionReceiversQuery","reactionReceiversResult","reactionReceivers","allUserIds","Set","uniqueUserIds","Array","from","filter","usersWithPotentialDuplicates","get","uniqueUsersByName","user","has","users","localeCompare","getIndividualStats","userId","_getIdsResult$","_getIdsResult$$values","_getIdsResult$2","_getIdsResult$2$value","_totalMessagesResult$","_totalMessagesResult$2","_timestampsResult$","_totalReactionsResult","_totalReactionsResult2","getIdsQuery","getIdsResult","userUUID","userServiceId","totalMessagesQuery","totalMessagesResult","totalMessagesSent","allTimestampsQuery","timestampsResult","mostPopularDay","dayCounts","fill","row","ts","date","Date","getDay","maxCount","max","popularDayIndex","indexOf","dayMap","totalReactionsQuery","totalReactionsResult","totalReactionsSent","loadUsers","loadIndividualStats"],"sources":["E:/ahste/Projects/signal-analytics/frontend/src/utils/database.ts"],"sourcesContent":["/*\n Utility helpers for decrypting and processing the Signal Desktop database.\n*/\n\n// Import CryptoJS for encryption/decryption\nimport CryptoJS from 'crypto-js';\n\n// Singleton pattern for SQL.js initialization\nlet sqlJsInstance: any = null;\nlet sqlJsInitPromise: Promise<any> | null = null;\n\nexport async function getSqlJs() {\n  if (sqlJsInstance) return sqlJsInstance;\n  if (!sqlJsInitPromise) {\n    sqlJsInitPromise = (async () => {\n      try {\n        const [SQLModule, wasmBinary] = await Promise.all([\n          import('sql.js'),\n          fetch('/sql-wasm.wasm').then(res => {\n            if (!res.ok) {\n              throw new Error(`Failed to fetch wasm file: ${res.statusText}`);\n            }\n            return res.arrayBuffer();\n          })\n        ]);\n\n        const initSqlJs = SQLModule.default as unknown as (config: any) => Promise<any>;\n        const SQL = await initSqlJs({ wasmBinary });\n        sqlJsInstance = SQL;\n        return SQL;\n      } catch (err) {\n        console.error('Failed to initialize sql.js:', err);\n        throw err;\n      }\n    })();\n  }\n  return sqlJsInitPromise;\n}\n\nexport const initializeSQL = async () => {\n  return getSqlJs();\n};\n\n// Helper to create a new SQL.js Database instance from ArrayBuffer\nexport async function createDatabaseFromBuffer(dbBuffer: ArrayBuffer) {\n  const SQL = await getSqlJs();\n  return new SQL.Database(new Uint8Array(dbBuffer));\n}\n\nexport interface Conversation {\n  id: string;\n  name: string;\n}\n\nexport interface Award {\n  winner: string | null;\n  count: number;\n}\n\nexport interface AnalyticsData {\n  all_conversations: Conversation[];\n  message_counts: {\n    by_day: Record<string, number>;\n    by_hour: Record<string, number>;\n  };\n  top_conversations: {\n    name: string;\n    count: number;\n  }[];\n  kpis: {\n    total_messages: number;\n    total_conversations: number;\n    avg_messages_per_day: number;\n  };\n  reactions: {\n    total_reactions: number;\n    top_emojis: { emoji: string; count: number }[];\n    top_emojis_by_author: Record<string, { emoji: string; count: number }[]>;\n  };\n  awards: {\n    most_messages_sent: Award;\n    most_reactions_given: Award;\n    most_reactions_received: Award;\n    most_mentioned: Award;\n    most_replied_to: Award;\n    most_media_sent: Award;\n  };\n}\n\nexport async function decryptDatabase(\n  encrypted: ArrayBuffer,\n  password: string\n): Promise<ArrayBuffer> {\n  try {\n    // The key from Signal's config is a long hex string. We only need the first 32 bytes (64 hex chars) for the AES key.\n    const keyHex = password.substring(0, 64);\n    const key = CryptoJS.enc.Hex.parse(keyHex);\n\n    // The first 16 bytes of the encrypted file are the IV\n    const iv = CryptoJS.lib.WordArray.create(encrypted.slice(0, 16));\n\n    // The rest of the file is the ciphertext\n    const ciphertext = CryptoJS.lib.WordArray.create(encrypted.slice(16));\n\n    // Decrypt using AES-256-CBC\n    const decrypted = CryptoJS.AES.decrypt(\n      { ciphertext: ciphertext } as any,\n      key,\n      {\n        iv: iv,\n        mode: CryptoJS.mode.CBC,\n        padding: CryptoJS.pad.Pkcs7,\n      }\n    );\n\n    // Convert the decrypted WordArray back to a Uint8Array\n    const decryptedBytes = decrypted.toString(CryptoJS.enc.Latin1);\n    const decryptedArray = new Uint8Array(decryptedBytes.length);\n    for (let i = 0; i < decryptedBytes.length; i++) {\n      decryptedArray[i] = decryptedBytes.charCodeAt(i);\n    }\n\n    return decryptedArray.buffer;\n  } catch (error) {\n    console.error('Error decrypting database:', error);\n    throw new Error('Failed to decrypt database. Check if the key is correct.');\n  }\n}\n\n// New handler to support both encrypted and unencrypted databases\nexport async function loadDatabase(\n  dbBuffer: ArrayBuffer,\n  key?: string,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  // Check for the SQLite header by comparing the first 16 bytes of the file\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00, // \"SQLite format 3\\0\"\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n\n  const isDecrypted =\n    fileHeader.length === sqliteHeader.length &&\n    fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    // Already decrypted, process directly\n    return processDatabase(dbBuffer, conversationIds);\n  } else if (key) {\n    // Encrypted, so decrypt first\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return processDatabase(decryptedBuffer, conversationIds);\n  } else {\n    // Encrypted but no key provided\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function processDatabase(\n  dbBuffer: ArrayBuffer,\n  conversationIds?: string[]\n): Promise<AnalyticsData> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n    const buildWhereClause = (tableAlias?: string, idColumn: string = 'conversationId') => {\n      if (!conversationIds || conversationIds.length === 0) return '';\n      const prefix = tableAlias ? `${tableAlias}.` : '';\n      const ids = conversationIds.map(id => `'${id}'`).join(',');\n      return `WHERE ${prefix}${idColumn} IN (${ids})`;\n    };\n\n    const messagesWhereClause = buildWhereClause();\n    const reactionsWhereClause = buildWhereClause();\n    const conversationsWhereClause = buildWhereClause(undefined, 'id');\n    const messagesJoinWhereClause = buildWhereClause('m');\n\n    const analytics: AnalyticsData & { userNamesById: Record<string, string> } = {\n      all_conversations: [],\n      message_counts: { by_day: {}, by_hour: {} },\n      top_conversations: [],\n      kpis: { total_messages: 0, total_conversations: 0, avg_messages_per_day: 0 },\n      reactions: { total_reactions: 0, top_emojis: [], top_emojis_by_author: {} },\n      awards: {\n        most_messages_sent: { winner: null, count: 0 },\n        most_reactions_given: { winner: null, count: 0 },\n        most_reactions_received: { winner: null, count: 0 },\n        most_mentioned: { winner: null, count: 0 },\n        most_replied_to: { winner: null, count: 0 },\n        most_media_sent: { winner: null, count: 0 },\n      },\n      userNamesById: {},\n    };\n\n    // Build user ID to name mapping from conversations\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]: [string, string, string, string]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) analytics.userNamesById[id] = name;\n          if (serviceId) analytics.userNamesById[serviceId] = name;\n        }\n      });\n    }\n    console.log('Constructed userNamesById mapping:', analytics.userNamesById);\n\n    if (!conversationIds || conversationIds.length === 0) {\n      const allConvosResults = db.exec(`\n        SELECT id, COALESCE(name, profileName, e164, id) as conversation_name\n        FROM conversations ORDER BY conversation_name ASC\n      `);\n      if (allConvosResults[0]) {\n        analytics.all_conversations = allConvosResults[0].values.map(([id, name]: [string, string]) => ({ id, name }));\n      }\n    }\n\n    // Standard Analytics Queries\n    const byDayResults = db.exec(`SELECT DATE(sent_at/1000, 'unixepoch') as date, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY date ORDER BY date ASC`);\n    const byHourResults = db.exec(`SELECT strftime('%H', sent_at/1000, 'unixepoch') as hour, COUNT(*) as count FROM messages ${messagesWhereClause} GROUP BY hour ORDER BY hour ASC`);\n    const topConvoResults = db.exec(`SELECT COALESCE(c.name, c.profileName, c.e164, c.id) as name, COUNT(m.rowid) as count FROM messages m JOIN conversations c ON m.conversationId = c.id ${messagesJoinWhereClause} GROUP BY name ORDER BY count DESC LIMIT 5`);\n    const kpiResults = db.exec(`SELECT (SELECT COUNT(*) FROM messages ${messagesWhereClause}) as total_messages, (SELECT COUNT(*) FROM conversations ${conversationsWhereClause}) as total_conversations`);\n    const reactionResults = db.exec(`SELECT emoji, fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause} GROUP BY emoji, fromId`);\n\n    // Award Queries\n    const mostMessagesSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsGivenQuery = `SELECT fromId, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} fromId IS NOT NULL GROUP BY fromId ORDER BY count DESC LIMIT 1`;\n    const mostReactionsReceivedQuery = `SELECT targetAuthorAci, COUNT(*) as count FROM reactions ${reactionsWhereClause ? `${reactionsWhereClause} AND` : 'WHERE'} targetAuthorAci IS NOT NULL GROUP BY targetAuthorAci ORDER BY count DESC LIMIT 1`;\n    const mostMentionedQuery = `SELECT mn.mentionAci, COUNT(*) as count FROM mentions mn JOIN messages m ON mn.messageId = m.id JOIN conversations c ON mn.mentionAci = c.serviceId ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} mn.mentionAci IS NOT NULL GROUP BY mn.mentionAci ORDER BY count DESC LIMIT 1`;\n    const mostRepliedToQuery = `SELECT json_extract(m.json, '$.quote.author') as repliedToAuthor, COUNT(*) as count FROM messages m ${messagesJoinWhereClause} ${messagesJoinWhereClause ? 'AND' : 'WHERE'} json_extract(m.json, '$.quote.author') IS NOT NULL GROUP BY repliedToAuthor ORDER BY count DESC LIMIT 1`;\n    const mostMediaSentQuery = `SELECT sourceServiceId, COUNT(*) as count FROM messages ${messagesWhereClause ? `${messagesWhereClause} AND` : 'WHERE'} hasAttachments = 1 AND sourceServiceId IS NOT NULL GROUP BY sourceServiceId ORDER BY count DESC LIMIT 1`;\n\n    const [mostMessagesSent, mostReactionsGiven, mostReactionsReceived, mostMentioned, mostRepliedTo, mostMediaSent] = [\n      db.exec(mostMessagesSentQuery),\n      db.exec(mostReactionsGivenQuery),\n      db.exec(mostReactionsReceivedQuery),\n      db.exec(mostMentionedQuery),\n      db.exec(mostRepliedToQuery),\n      db.exec(mostMediaSentQuery),\n    ];\n\n    // Process results\n    if (byDayResults[0]) analytics.message_counts.by_day = Object.fromEntries(byDayResults[0].values);\n    if (byHourResults[0]) analytics.message_counts.by_hour = Object.fromEntries(byHourResults[0].values);\n    if (topConvoResults[0]) analytics.top_conversations = topConvoResults[0].values.map(([name, count]: [string, number]) => ({ name, count }));\n    if (kpiResults[0]) {\n      const [total_messages, total_conversations] = kpiResults[0].values[0] as [number, number];\n      analytics.kpis = {\n        total_messages,\n        total_conversations,\n        avg_messages_per_day: Object.keys(analytics.message_counts.by_day).length ? Math.round(total_messages / Object.keys(analytics.message_counts.by_day).length) : 0,\n      };\n    }\n    if (reactionResults[0]) {\n      const emojiCounts: Record<string, number> = {};\n      const authorEmojiCounts: Record<string, Record<string, number>> = {};\n      reactionResults[0].values.forEach(([emoji, fromId, count]: [string, string, number]) => {\n        analytics.reactions.total_reactions += count;\n        emojiCounts[emoji] = (emojiCounts[emoji] || 0) + count;\n        if (!authorEmojiCounts[fromId]) authorEmojiCounts[fromId] = {};\n        authorEmojiCounts[fromId][emoji] = (authorEmojiCounts[fromId][emoji] || 0) + count;\n      });\n      analytics.reactions.top_emojis = Object.entries(emojiCounts).sort(([, a], [, b]) => b - a).slice(0, 10).map(([emoji, count]) => ({ emoji, count }));\n      for (const authorId in authorEmojiCounts) {\n        analytics.reactions.top_emojis_by_author[authorId] = Object.entries(authorEmojiCounts[authorId]).sort(([, a], [, b]) => b - a).slice(0, 3).map(([emoji, count]) => ({ emoji, count }));\n      }\n    }\n\n    // Process Award Results\n    if (mostMessagesSent[0]?.values[0]) {\n      const [winner, count] = mostMessagesSent[0].values[0] as [string, number];\n      analytics.awards.most_messages_sent = { winner, count };\n    }\n    if (mostReactionsGiven[0]?.values[0]) {\n      const [winner, count] = mostReactionsGiven[0].values[0] as [string, number];\n      analytics.awards.most_reactions_given = { winner, count };\n    }\n    if (mostReactionsReceived[0]?.values[0]) {\n      const [winner, count] = mostReactionsReceived[0].values[0] as [string, number];\n      analytics.awards.most_reactions_received = { winner, count };\n    }\n    if (mostMentioned[0]?.values[0]) {\n      const [winner, count] = mostMentioned[0].values[0] as [string, number];\n      analytics.awards.most_mentioned = { winner, count };\n    }\n    if (mostRepliedTo[0]?.values[0]) {\n      const [winner, count] = mostRepliedTo[0].values[0] as [string, number];\n      analytics.awards.most_replied_to = { winner, count };\n    }\n    if (mostMediaSent[0]?.values[0]) {\n      const [winner, count] = mostMediaSent[0].values[0] as [string, number];\n      analytics.awards.most_media_sent = { winner, count };\n    }\n\n    return analytics;\n  } catch (error) {\n    console.error('Error processing database:', error);\n    throw new Error('Failed to process database');\n  }\n}\n\nexport interface User {\n  id: string;\n  name: string;\n}\n\nexport interface IndividualStatsData {\n  totalMessagesSent: number;\n  mostPopularDay: string;\n  totalReactionsSent: number;\n}\n\nexport async function getUsers(dbBuffer: ArrayBuffer): Promise<User[]> {\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Build a comprehensive name mapping from the conversations table\n    const nameMap = new Map<string, string>();\n    const nameMappingQuery = `\n      SELECT id, serviceId, profileFullName, profileName\n      FROM conversations\n      WHERE type = 'private'\n    `;\n    const nameMappingResults = db.exec(nameMappingQuery);\n    if (nameMappingResults[0]) {\n      nameMappingResults[0].values.forEach(([id, serviceId, profileFullName, profileName]: [string, string, string, string]) => {\n        const name = (profileFullName || profileName || '').trim();\n        if (name) {\n          if (id) nameMap.set(id, name);\n          if (serviceId) nameMap.set(serviceId, name);\n        }\n      });\n    }\n\n    // Collect all unique user IDs from messages and reactions\n    const messageSendersQuery = `SELECT DISTINCT sourceServiceId FROM messages WHERE sourceServiceId IS NOT NULL`;\n    const messageSendersResult = db.exec(messageSendersQuery);\n    const messageSenders = messageSendersResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionGiversQuery = `SELECT DISTINCT fromId FROM reactions WHERE fromId IS NOT NULL`;\n    const reactionGiversResult = db.exec(reactionGiversQuery);\n    const reactionGivers = reactionGiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const reactionReceiversQuery = `SELECT DISTINCT targetAuthorAci FROM reactions WHERE targetAuthorAci IS NOT NULL`;\n    const reactionReceiversResult = db.exec(reactionReceiversQuery);\n    const reactionReceivers = reactionReceiversResult[0]?.values.map(([id]: [string]) => id) || [];\n\n    const allUserIds = [...new Set([...messageSenders, ...reactionGivers, ...reactionReceivers])];\n    const uniqueUserIds = Array.from(new Set(allUserIds.filter(id => typeof id === 'string' && id)));\n\n    // Create the User[] array, using the name map\n    const usersWithPotentialDuplicates: User[] = uniqueUserIds\n      .map(id => ({\n        id,\n        name: nameMap.get(id) || id, // Use mapped name, fallback to ID\n      }));\n\n    // Deduplicate users by name, keeping the first occurrence\n    const uniqueUsersByName = new Map<string, User>();\n    for (const user of usersWithPotentialDuplicates) {\n      if (!uniqueUsersByName.has(user.name)) {\n        uniqueUsersByName.set(user.name, user);\n      }\n    }\n\n    const users = Array.from(uniqueUsersByName.values())\n      .sort((a, b) => a.name.localeCompare(b.name));\n\n    return users;\n  } catch (error) {\n    console.error('Error getting users:', error);\n    throw new Error('Failed to get users from the database.');\n  }\n}\n\n\nexport async function getIndividualStats(dbBuffer: ArrayBuffer, userId: string): Promise<IndividualStatsData> {\n  if (!userId) {\n    throw new Error('User ID is required to get individual stats.');\n  }\n\n  try {\n    const db = await createDatabaseFromBuffer(dbBuffer);\n\n    // Find the canonical serviceId AND id for the given user ID\n    const getIdsQuery = `SELECT id, serviceId FROM conversations WHERE id = '${userId}' OR serviceId = '${userId}' LIMIT 1`;\n    const getIdsResult = db.exec(getIdsQuery);\n    const userUUID = getIdsResult[0]?.values[0]?.[0] as string || userId;\n    const userServiceId = getIdsResult[0]?.values[0]?.[1] as string || userId;\n\n    const totalMessagesQuery = `SELECT COUNT(*) FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const totalMessagesResult = db.exec(totalMessagesQuery);\n    const totalMessagesSent = totalMessagesResult[0]?.values[0]?.[0] as number || 0;\n\n    // Calculate most popular day in JS for robustness\n    const allTimestampsQuery = `SELECT sent_at FROM messages WHERE sourceServiceId = '${userServiceId}'`;\n    const timestampsResult = db.exec(allTimestampsQuery);\n    let mostPopularDay = 'N/A';\n    if (timestampsResult[0]?.values.length > 0) {\n      const dayCounts = Array(7).fill(0); // Sunday - Saturday\n      timestampsResult[0].values.forEach((row: any[]) => {\n        const ts = row[0] as number;\n        const date = new Date(ts);\n        dayCounts[date.getDay()]++;\n      });\n      const maxCount = Math.max(...dayCounts);\n      const popularDayIndex = dayCounts.indexOf(maxCount);\n      const dayMap = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n      mostPopularDay = dayMap[popularDayIndex];\n    }\n\n    // Use the user's UUID (conversations.id) for reactions, as per the user's view\n    const totalReactionsQuery = `SELECT COUNT(*) FROM reactions WHERE fromId = '${userUUID}'`;\n    const totalReactionsResult = db.exec(totalReactionsQuery);\n    const totalReactionsSent = totalReactionsResult[0]?.values[0]?.[0] as number || 0;\n\n    return {\n      totalMessagesSent,\n      mostPopularDay,\n      totalReactionsSent,\n    };\n  } catch (error) {\n    console.error(`Error getting stats for user ${userId}:`, error);\n    throw new Error('Failed to get individual stats.');\n  }\n}\n\nexport async function loadUsers(\n  dbBuffer: ArrayBuffer,\n  key?: string\n): Promise<User[]> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getUsers(dbBuffer);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getUsers(decryptedBuffer);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n\nexport async function loadIndividualStats(\n  dbBuffer: ArrayBuffer,\n  key: string | undefined,\n  userId: string\n): Promise<IndividualStatsData> {\n  const sqliteHeader = new Uint8Array([\n    0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,\n    0x20, 0x33, 0x00,\n  ]);\n  const fileHeader = new Uint8Array(dbBuffer.slice(0, 16));\n  const isDecrypted = fileHeader.length === sqliteHeader.length && fileHeader.every((byte, i) => byte === sqliteHeader[i]);\n\n  if (isDecrypted) {\n    return getIndividualStats(dbBuffer, userId);\n  } else if (key) {\n    const decryptedBuffer = await decryptDatabase(dbBuffer, key);\n    return getIndividualStats(decryptedBuffer, userId);\n  } else {\n    throw new Error('This database is encrypted. Please provide a key.');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}